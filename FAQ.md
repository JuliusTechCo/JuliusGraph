# Frequently Asked Questions

By Julius Technologies Inc (email: info@juliustech.co)

Julius is an auto-scaling, low-code and visual graph computing solution. It can build and run sophisticated data and analytical pipelines as directed acyclic graphs (DAG) with very little coding. Readers are referred to [this blog](https://www.juliustech.co/blog/why-graph-computing-is-stellar) for a high level overview of the benefits of graph computing, and [this repo](https://github.com/JuliusTechCo/JuliusGraph) for [tutorials](https://juliustechco.github.io/JuliusGraph) and instructions to sign up for free developer access.

This FAQ page answers some of the most common questions from our users and clients. They are organized by subjects.

### Graph Computing and RuleDSL

1. What are the benefits of graph computing and why we need computational DAGs (directed acyclic graphs)? 
 
    Graph computing solves the most common and challenging problems for building complex data and analytical pipelines and systems. These challenges includes scalability, transparency, explainability, lineage, adaptability and reproducibility. The reason is that computational DAG is an ideal representation for building generic solutions for these common challenges.  Please refer to [this blog](https://www.juliustech.co/blog/why-graph-computing-is-stellar) for a full explanation.

    Julius Graph Engine is the first solution that delivers the full benefits of graph computing in a low-code interface, allowing a small development team to build sophisticated, scalable and transparent systems with very little code. 

2. What are the `Atom` and `RuleDSL` in Julius?

    `Atom` and `RuleDSL` are the two fundamental constructs Julius uses to create and execute computational DAGs.

    `Atom` stands for atomic operation, it encapsulates the functions being called at individual node in Julius' computational DAG. Atom is the minimal unit of distribution and caching in Julius' computational DAG, it cannot broken apart further for these purposes. Atom is a generic base interface that can be inherited in any major programming languages, such as C++, Pyton, Java, Julia, .Net and R etc. Existing libraries written in these languages can be easily wrapped up under the `Atom` interface.

    `RuleDSL` is a high level declarative domain specific language (DSL) for creating computational DAGs. RuleDSL features an easy to use and low-code syntax connects individual `Atoms` to create applications or systems as computational DAGs.

    Please refer to Julius [tutorials](https://juliustechco.github.io/JuliusGraph) for more detailed explanations and examples of using Atom and RuleDSL.

3. How does Julius Graph Engine access data?
   
    Julius Graph Engine creates and runs computational DAGs in two stages:
    
      * Build the data and analytical pipeline as a computational DAG (directed acyclic graph) from `RuleDSL` 
      * Run the computational DAG to process data and produce the results.
    
    Both stages can access data. The data in stage 1 is supplied by binding data to the rule parameters in `RuleDSL`. The data in stage 2 are sourced by individual Atoms, which can read data from any source, such as database, web URL, static files etc.
    
    The key advantage of two stage data feeds is that the first stage usually require a small amount of data for constructing the DAG. Once the DAG is built, it can be distributed to multiple workers, so that the heavy lifting of data processing in stage 2 can be done in parallel, thus achieving much better performance for both graph creation and execution. A developer has full control over which types of data are fed at each stage through the `RuleDSL`. 

4. How does `RuleDSL` differ from ordinary programming languages such as Python/C++/Java? 

    General purpose programming languages like Python, C/C++ and Java are low-level and imperative, a developer has to specify the program's entire execution step by step, which is a lot of coding! In comparison, the RuleDSL is a high level declarative domain specific language (DSL) for constructing computational DAGs. Using RuleDSL, a developer doesn't need to explicitly specify every step of a program's execution, instead he/she only need to declare the key business concepts and their logical dependencies. The Julius Graph Engine then automatically create an executable computational DAG from the RuleDSL declarations. 
    
    Therefore, it requires much less code in RuleDSL to specify the same business logic compared to the traditional programming languages, as most of the boilerplate flow control code are automatically generated by the Julius Graph Engine. The RuleDSL therefore doesn't need any of the complex flow control syntax in the traditional programming languages, such as variables, loops, functions, classes, or branches etc. It is much easier for a non-programmers to learn and use. Furthermore, its declarative syntax gives the Julius Graph Engine a lot more freedom to optimize its execution, especially the parallel distribution over multiple machines. RuleDSL low-code syntax therefore facilitates much better scalability and performance.

5. How can computational DAG, which is acyclic, handle loops? 

    It is true that the computational DAG is acyclic, thus there can't be any loops in the DAG by construction. However, it doesn't mean that we can't use the DAG to express a looping logic. To the contrary, there are multiple ways to express looping logic in a computational DAG:

      * create loops inside an Atom
      * create a set of nodes, each represents a batch of iterations in the loop. For example, if a Monte Carlo simulation runs with 100,000 path, we can create 100 nodes, each runs 1000 MC paths. 
      * use recursion in RuleDSL if there are dependencies between iterations 
      * run the computational DAG multiple times or in streaming mode

    Any of these options to be implemented easily using RuleDSL, without any special syntax for looping in the RuleDSL. There is an example of running Monte Carlo simulation by streaming a computational DAG in the [tutorials](https://juliustechco.github.io/JuliusGraph).

6. How to express conditional branches in RuleDSL and computational DAGs?

    Similar to looping, branch conditions can also be expressed in multiple ways:

      * via rule polymorphism, where a different rule is invoked depending on the type or values of the rule parameter during DAG creation.
      * write an Atom with a select logic, where one of the input is selected as output according to certain conditions at run time.

    The first approach is more efficient as the branch condition is resolved during DAG construction. 
    Either of these options can be implemented easily in RuleDSL, without the need for any special syntax.

### Capabilities and Use Cases

1. Does Julius Graph Engine support streaming and live use cases?

    Absolutely, the same computation DAG can run in either batch or streaming mode, without much code change. Please see the [tutorials](https://juliustechco.github.io/JuliusGraph) for examples of streaming use cases.

1. What are the best use cases for graph computing and Julius Graph Engine? 

    The Julius Graph Engine is well suited for any data and analytical use case. Julius adds more value to enterprise systems with complex data and analytical pipelines, which often suffer from poor transparency, lineage, scalability and visibility. 
    
1. Can I use Julius for building machine learning applications and systems?

    Definitely, machine learning is a great use case for Julius. Julius' computational DAG offers tremendous transparency, explainability and auditability for building ML pipelines and applications. Julius computational DAG can incorporates all the steps in a typical ML pipeline, including data cleansing, feature engineering, training, inference and hyper parameter tuning. It aslo offers great MLOps support, such as easy persisting and recovery of ML experiments. Please refer to Julius [tutorials](https://juliustechco.github.io/JuliusGraph) for examples of ML use cases.
    
1. Can Julius Graph Engine handle large data or heavy computations?

    Absolutely, Julius can automatically distribute the computational DAG to many computers, without the need for any code changes in RuleDSL or Atoms.  The ability to scale without code changes is a huge advantage of Julius, it allows efficient parallel processing of large data and heavy computation, and facilitating quick migration of a model from development to production. The distributed machine learning in Julius [tutorials](https://juliustechco.github.io/JuliusGraph) shows how easy it is to automatically distribute computational DAGs.

1. How big can Julius' computational DAG be?

    Julius Graph Engine can quickly create computational DAGs with tens of millions of nodes from a single computer. DAGs up to billions of nodes can be efficiently created in parallel by Julius. Once created, Julius can automatically distribute the computational DAGs to hundreds of computers for efficient parallel executions.

1. Are intermediate results in the computational DAG cached by Julius?

    Yes, Julius automatically cache the intermediate results for every nodes in memory. The cached results add great value for both developers and users. These node level results are tremendously useful for many purposes, such as:

      * explain, audit and verify the results
      * debug and tracking issues 
      * enables fast scenario runs, as only dependent nodes needs to be re-computed for any input changes
      * facilitate adjoint algorithmic differentiation (AAD)

    In comparison, the cost to cache all intermediate node level results in memory is small. Julius can automatically distribute the computational DAG to a large number of computers, and access a large amount of memory.

2. Can I access and visualize intermediate results in the computational DAG?

    Julius comes with an intuitive and easy-to-use web UI, where a user can navigate the computational DAG, and visualize all the intermediate data by simply clicking on individual nodes in the DAG. All data are also accessible via Julius API. Please refer to the [tutorials](https://juliustechco.github.io/JuliusGraph) for examples of using the web UI and Julius API.

### Integration

1. What programming languages can I use with Julius Graph Engine?

    Atoms can be written in any major programming language such as C/C++, Python, Java, .Net, R and Julia etc. Existing data and analytical libraries written in these programming languages can be wrapped up as `Atoms` and used by Julius Graph Engine.

    The Julius Graph Engine also features easy-to-use APIs that can be called from any programming languages. 

1. How to convert my Python/C++/Java/.Net/R/Julia/SQL applications to Julius, and get the benefits of Graph?

    The great news is that your existing data and analytical libraries built in these languages can be re-used. You don't have to abandon your battle tested production libraries and restart from scratch! The migration to Julius involves two easy steps:
    
      * wrap the existing data and analytical classes and functions using the Julius' `Atom` base class. Julius offers generic wrappers that works out of box for modern programming languages that support reflection, such as Python, Java, R, .Net and Julia etc. These generic reflection based Atom wrapper works automatically for any classes and functions written in these languages. For older languages that do not support reflection, such as C/C++, additional manual effort is required to write these wrappers for individual functions and classes, however this additional work is largely machanical and can be done rather quickly. 
      * declare the entire data and analytical pipeline using Julius RuleDSL, which can reference and use the existing libaries via the `Atom` wrappers. This step only require minimal efforts and a small amount of coding, thanks to the low-code nature of RuleDSL. A complex data and analytical pipeline with hundreds or thousands of nodes can be built with a few dozen lines of rules in RuleDSL, as shown in Julius' [tutorials](https://juliustechco.github.io/JuliusGraph).
      
   The conversion only require minimal efforts if the existing system is built in a modern language like Python, Java, .Net, R, Julia etc.  Our experience shows that a complex real world system can be fully converted in a few weeks, by developers who are knowledgeable with the system's business logic and code base. For C/C++ applications and systems, it would require more time and efforts for writing and testing the wrappers manually.

1. How to integrate Julius Graph Engine with an existing system or application?

    Existing systems and applications can easily access Julius' Graph Engine using Julius' easy-to-use APIs. Julius supports a low level API for Julia, C/C++ and Python clients, as well as a high level REST API that can be called from any programming languages. The low-level API is faster and more granular, which is recommended for building high performing systems. The high-level API is easy to use and integrate, which is recommended for general use cases.
   
1. What databases and data sources Julius supports?

   Julius comes with a rich set of data connectors out of box, including relational databases, NoSQL databases (Hadoop/Spark etc), data files, web data sources etc. If you need additional data connectors Julius does not yet support, you can write your own connectors as new Atoms using any major programming languages.
   
2. Can I use data visualization tools such Tableau and Qlik with Julius?

   Absolutely. Results from Julius graph can be fed into Tableau and Qlik for visualization and reporting.


### Installation
1. How to install Julius?

    Julius installation is super easy: Julius ships with a single docker image. A client can simply install this docker image on however number of computers he/she chooses to run, which can be on public cloud or private on-premise cluster. Julius only require minimal configurations after installation, most of the orchistration and configuration are handled automatically within the Julius docker container.
  
1. What operating systems does Julius Graph Engine support?

    Both Linux and Windows.

1. What hardware environment can Julius Graph Engine run on?

    The Julius Graph Engine can be deployed to any cloud computer provider, or private on-premise clusters in an organization. Julius currently only support AMD/intel x86-64 CPU architecture. 

1. How can a client protect its intellectual property when running the Julius Graph Engine in the cloud?

    The Julius Graph Engine can be integrated to clients' internal authentication process, so that only authorized personnel have access. Julius can be deployed on premise or in a single tenant environment on cloud, providing additional protection. 

1. How much does it cost to license Julius?
   
   Developers can access and use Julius for free, the instructions to sign up for developer access is [here](https://github.com/JuliusTechCo/JuliusGraph). The cost of commercial licenses depend on the use case and the level of support required, please email info@juliustech.co for licensing questions.

### Comparables
1. The Julius Graph Engine seems to be too good to be true, why hasn't anyone else done this before?

    The answer is twofold: the first is that there are a myriad of technological hurdles to overcome in order to design and implement such a generic graph computing solution; secondly the solution leverages many new technologies that have only become mature in recent years, such as cloud computing.

1. What is the main difference between the Julius Graph Engine from a collaborative development solution like Beacon?

    Platforms like Beacon offer integrated and collaborative development/deployment environments so that firms can be more efficient in managing and deploying complex code bases. In contrast, Julius Graph Engine attacks the problem from its root by dramatically reducing the amount of coding and efforts required for building complex systems, by taking advantage of the graph computing and the low code RuleDSL. Using Julius Graph Engine, there is a much less need for sophisticated collaborative development tools, as there is much less code to write and manage.

1. How does Julius Graph Engine's RuleDSL and computation DAG differ from Excel's worksheet formula and its dependency graph?

    Julius RuleDSL is much more generic and expressive than Excel's worksheet formulae. The Rules support both type and value based polymorphism, while Excel formulas are hard coded with specific cell or range. An Excel workbook often has thousands of formulae created by copy/paste functions, which is error prone and difficult to audit and change. In comparison, similar logic can be implemented succinctly by a few rules in RuleDSL, thanks to its expressivity and polymorphism.

    In addition, the Julius Graph Engine is much more performant and scalable than Excel, it can handle large volumen of data and computation by running in parallel on many computers. Therefore Julius is a production solution for enterprise systems, while Excel is mainly a personal and office application.

1. How does Julius Graph Engine differ from other software packages that also use computational DAGs, such as Dask, Tensorflow and Dagger.jl?

    Julius RuleDSL is specifically designed for efficient creation and execution of computational DAGs. It offers much better performance and scalability, as shown in our [tutorials](https://juliustechco.github.io/JuliusGraph) and [benchmark](https://juliustechco.github.io/JuliusGraph/dev/pages/t007_benchmark.html). In addition, Julius RuleDSL is low-code, it takes much less code and efforts to implement the same functionality than other tools.


### Development Environment
1. What IDE does Julius support?

    Jupyter lab/notebook and VScode. 

2. How do I debug a large computational DAG?

    Julius offers great tools for debugging. Using Julius web UI, a developer can quickly navigate and visualize every intermediate results in the computational DAG, allowing quickly track down of bugs to individual nodes. Julius offers an API call that can download the entire state (including data and Atom) of any node in the distributed DAG to his/her local computer, and recreate the error conditions locally. Then the developer then can attach a debugger to the Atom and step through its execution to pin down the error. 

3. What if there is an error in the computational DAG?

    Julius offers great error handling and recovery capabilities. When there is an error, the web UI will highlight the node with the error and bring a user to the node with one click. By default, the DAG execution will halt until the error is corrected. Julius also supports a trigger mechanism that allows errors to be automatically reported and handled, so that the DAG execution can proceed with errors.


