# Frequently Asked Questions

By Julius Technologies Inc (email: info@juliustech.co)

Julius is an auto-scaling, low-code and visual graph computing solution. It can build and run sophisticated data and analytical pipelines as directed acyclic graphs (DAG) with very little coding. Readers are referred to [this blog](https://www.juliustech.co/blog/why-graph-computing-is-stellar) for a high level overview of the benefits of graph computing, and [this repo](https://github.com/JuliusTechCo/JuliusGraph) for [tutorials](https://juliustechco.github.io/JuliusGraph) and instructions to sign up for free developer access.

This FAQ page answers some of the most common questions from our users and clients. They are organized by subjects.

### Graph Computing and RuleDSL

1. What are the benefits of graph computing and why we need computational DAGs (directed acyclic graphs)? 
 
    Graph computing solves the most common and challenging problems for building complex data and analytical pipelines and systems. These challenges includes scalability, transparency, explainability, lineage, adaptability and reproducibility. The reason is that computational DAG is an ideal representation for building generic solutions for these common challenges.  Please refer to [this blog](https://www.juliustech.co/blog/why-graph-computing-is-stellar) for a full explanation.

    Julius Graph Engine is the first solution that delivers the full benefits of graph computing using a low-code RuleDSL, allowing a small development team to build sophisticated, scalable and transparent systems with very little code. 

2. What are the `Atom` and `RuleDSL` in Julius?

    `Atom` and `RuleDSL` are the two fundamental constructs in Julius for creating computational DAGs.

    `Atom` stands for atomic operation, it encapsulates the functions being performed at individual nodes in Julius' computational DAG. Atom is the minimal unit of distribution and caching in Julius' computational DAG. Atom is a generic base interface that can be inherited in any major programming languages, such as C++, Pyton, Java, Julia, .Net and R etc. Existing libraries written in these languages can be easily wrapped up under the `Atom` interface.

    `RuleDSL` is a high level declarative domain specific language (DSL) for defining computational DAGs. RuleDSL features an easy to use and low-code syntax that connects individual Atoms to create the computational DAG, which captures the entire data and analytical pipeline for an applications or a system.

    Please refer to Julius [tutorials](https://juliustechco.github.io/JuliusGraph) for more detailed explanations and examples of using Atom and RuleDSL.

3. How does Julius Graph Engine access data?
   
    Julius Graph Engine creates and runs computational DAGs in two stages:
    
      * Build the data and analytical pipeline as a computational DAG (directed acyclic graph) from `RuleDSL` 
      * Run the computational DAG to process data and produce the results.
    
    Both stages can access data. The data in stage 1 is supplied by binding data to the rule parameters in `RuleDSL`. The data in stage 2 are sourced by individual Atoms, which can read data from any source, such as database, web URL, static files etc.
    
    The key advantage of two stage data feeds is that the first stage usually require a small amount of data for constructing the DAG. Once the DAG is built, it can be distributed to multiple workers, so that the heavy lifting of data processing in stage 2 can be done in parallel. This two stage data feeds thus achieves much better performance for both graph creation and execution. A developer has full control over which types of data are fed at each stage through the `RuleDSL`. 

4. How does `RuleDSL` differ from ordinary programming languages such as Python/C++/Java? 

    General purpose programming languages like Python, C/C++ and Java are low-level and imperative, a developer has to specify the program's entire execution step by step, which is a lot of coding. In comparison, the RuleDSL is a high level declarative domain specific language (DSL) for constructing computational DAGs. Using RuleDSL, a developer doesn't need to explicitly specify every step of a program's execution, instead he/she only need to declare the key business concepts and their logical dependencies. The Julius Graph Engine then automatically create an executable computational DAG from the RuleDSL declarations. 
    
    Therefore, it requires much less code in RuleDSL to specify the same business logic compared to the traditional programming languages, as most of the boilerplate flow control code are automatically generated by the Julius Graph Engine. The RuleDSL therefore doesn't need any of the complex flow control syntax in the traditional programming languages, such as variables, loops, functions, classes, or branches etc. It is therefore much easier for a non-programmers to learn and use. Furthermore, its declarative syntax gives the Julius Graph Engine a lot more freedom to optimize its execution at run time, especially the parallel distribution over multiple machines. 
    
    Less is more: Julius RuleDSL gives you much better scalability and performance with much less coding.

5. How can computational DAG, which is acyclic, handle loops? 

    It is true that there can't be any loops in the DAG by construction. However, it doesn't mean that we can't use the DAG to express looping logic. To the contrary, there are multiple ways to express looping logic in a computational DAG:

      * loops can be created inside an Atom (i.e., within a single node in the DAG)
      * create a set of nodes, each represents a batch of iterations in the loop. For example, if a Monte Carlo simulation runs with 100,000 path, we can create 100 nodes, each runs 1000 MC paths. 
      * use recursion in RuleDSL if there are dependencies between iterations 
      * run the computational DAG multiple times or in streaming mode

    Any of these options can be implemented easily using RuleDSL, without the need for any special syntax for looping. There is an example of running Monte Carlo simulation by streaming a computational DAG in the [tutorials](https://juliustechco.github.io/JuliusGraph).

6. How to express conditional branches in RuleDSL and computational DAGs?

    Similar to looping, conditional branches can also be expressed in multiple ways:

      * via rule polymorphism in RuleDSL, where a different rule is invoked depending on the type or values of the rule parameter during DAG creation.
      * write an Atom with a select logic, where one of the input is selected as output according to certain conditions at run time.

    The first approach is more efficient as the branch condition is resolved during DAG construction. 
    Either of these options can be implemented easily in RuleDSL, without the need for any special branching syntax.

### Capabilities and Use Cases

1. Does Julius Graph Engine support streaming and live use cases?

    Absolutely, the same computation DAG can run in either batch or streaming mode, without much code change. Please see the [tutorials](https://juliustechco.github.io/JuliusGraph) for examples of streaming use cases.

1. What are the best use cases for graph computing and Julius Graph Engine? 

    The Julius Graph Engine is well suited for any data and analytical use case. Julius adds more value to enterprise systems with complex data and analytical pipelines, which tend to suffer more from poor transparency, lineage, scalability and visibility. 
    
2. Can I use Julius for building machine learning applications and systems?

    Definitely, machine learning is a great use case for Julius. Julius' computational DAG offers tremendous transparency, explainability and auditability for building ML pipelines and applications. Julius computational DAG can incorporate all the steps in a typical ML pipeline, including data cleansing, feature engineering, training, inference and hyper parameter tuning. It aslo offers great MLOps support, such as easy persisting and recovery of ML experiments. Please refer to Julius [tutorials](https://juliustechco.github.io/JuliusGraph) for examples of ML use cases.
    
3. Can Julius Graph Engine handle large data or heavy computations?

    Absolutely, Julius can automatically distribute the computational DAG to many computers, without the need for any code changes in RuleDSL or Atoms.  The ability to scale without code changes is a huge advantage of Julius, it allows efficient parallel processing of large data and heavy computation, and facilitating quick migration of a model from development to production. The distributed machine learning in Julius [tutorials](https://juliustechco.github.io/JuliusGraph) shows how easy it is to automatically distribute computational DAGs.

4. How big can Julius' computational DAG be?

    Julius Graph Engine can quickly create computational DAGs with tens of millions of nodes from a single computer. Julius also supports parallelism for DAG creation, DAGs up to billions of nodes can be efficiently created in parallel. Once created, Julius can automatically distribute the computational DAGs to hundreds of computers for efficient parallel executions.

5. Are intermediate results in the computational DAG cached by Julius?

    Yes, Julius automatically cache the intermediate results for every node in the computational DAG. The cached results add great value for both developers and users. These node level results are tremendously useful for many purposes, such as:

      * explain, audit and verify the final results
      * debug and tracking issues 
      * enables fast scenario runs, as only dependent nodes needs to be re-computed from any input changes
      * facilitate adjoint algorithmic differentiation (AAD)

    In comparison, the cost to cache all intermediate node level results in memory is relatively small, as Julius can automatically distribute the computational DAG to a large number of computers, and access an unlimited amount of memory.

6. How do I access and visualize intermediate results in the computational DAG?

    Julius comes with an intuitive and easy-to-use web UI, where a user can navigate the computational DAG, and visualize all the intermediate data by simply clicking on individual nodes in the DAG. All data are also accessible via Julius API. Please refer to the [tutorials](https://juliustechco.github.io/JuliusGraph) for examples of using the web UI and Julius API.

### Integration

1. What programming languages can I use with Julius Graph Engine?

    Atoms can be written in any major programming language such as C/C++, Python, Java, .Net, R and Julia etc. Existing data and analytical libraries written in these programming languages can be wrapped up as `Atoms` and used by Julius Graph Engine.

    The Julius Graph Engine also features easy-to-use APIs that can be called from any programming languages. 

1. How to convert my Python/C++/Java/.Net/R/Julia/SQL applications to Julius, and get the benefits of Graph?

    The great news is that your existing data and analytical libraries in these languages can be re-used. You don't have to abandon your battle tested libraries and restart from scratch! The migration of an application or system to Julius involves two easy steps:
    
      * wrap the existing data and analytical classes and functions using the Julius' `Atom` base class. Julius offers generic wrappers that works out of box for modern programming languages that support reflection, such as Python, Java, R, .Net and Julia etc. These generic reflection based Atom wrapper works automatically for any classes and functions in these languages. For older languages that do not support reflection, such as C/C++, additional manual effort is required to write Atom wrappers for individual functions and classes, however this additional work is largely machanical and can be done rather quickly by experienced developers. 
      * declare the entire data and analytical pipeline using Julius RuleDSL, which can reference and use the existing libaries via the `Atom` wrappers. This step only require minimal efforts and a small amount of coding, thanks to the low-code nature of RuleDSL. A complex data and analytical pipeline with hundreds or thousands of nodes can be built with a few dozen lines of rules in RuleDSL, as shown in Julius' [tutorials](https://juliustechco.github.io/JuliusGraph).
      
   The conversion only require minimal efforts if the existing system is built in a modern programming language.  Our experience shows that a complex real world system can be fully converted in a few weeks, by developers who are knowledgeable with the system's business logic and code base. For C/C++ applications and systems, it would require more time and efforts for writing and testing the wrappers manually.

2. Can I mix and match Atoms written in different programming languages in the same computational DAG?

    Yes! Julius automatically takes care of the interop between them if these Atoms' input and output are all of standard types. Additional development work, such as serialization, is only require if you want to pass a non-standard object from one language to another.

3. How to integrate Julius Graph Engine with an existing system or application?

    Existing systems and applications can  access Julius' Graph Engine via Julius' easy-to-use APIs. Julius supports a low level API for Julia, C/C++ and Python clients, as well as a high level REST API that can be called from any programming languages. The low-level API is faster and more granular, which is recommended for building high performing systems. The high-level API is easy to use and integrate, which is recommended for general use cases.
   
4. What databases and data sources Julius supports?

   Julius comes with a rich set of data connectors out of box, including relational databases, NoSQL databases (Hadoop/Spark etc), data files, web data sources etc. If you need additional data connectors Julius does not yet support, you can write your own connectors by inheriting from the Atom interface, using any major programming languages.
   
5. Can I use data visualization tools such Tableau and Qlik with Julius?

   Absolutely. Results from Julius graph can be fed into Tableau and Qlik for visualization and reporting.


### Installation
1. How to install Julius?

    Julius installation is super easy: Julius ships with a single docker image. A client can simply install this docker image on however number of computers he/she chooses to run, which can be on public cloud or private on-premise cluster. Julius only require minimal configurations after installation, most of the orchistration and configuration are handled automatically within the Julius docker container.
  
1. What operating systems does Julius Graph Engine support?

    Both Linux and Windows.

1. What hardware environment can Julius Graph Engine run on?

    The Julius Graph Engine can be deployed to any cloud computer provider, or private on-premise clusters in an organization.

2. How can a client protect its intellectual property when running the Julius Graph Engine in the cloud?

    The Julius Graph Engine can be integrated to clients' internal authentication process, so that only authorized personnel have access. Julius can be deployed on premise or in a single tenant environment on cloud, providing additional protection. 

3. How much does it cost to license Julius?
   
   Developers can access and use Julius for free, the instructions to sign up for developer access is [here](https://github.com/JuliusTechCo/JuliusGraph). The cost of commercial licenses depend on the use case and the level of support required, please email info@juliustech.co for licensing questions.

### Comparables
1. The Julius Graph Engine seems to be too good to be true, why hasn't anyone else done this before?

    The answer is twofold: the first is that there are a myriad of technological hurdles to overcome in order to design and implement such a generic graph computing solution; secondly the solution leverages many new technologies that have only become mature in recent years, such as cloud computing.

1. What is the main difference between the Julius Graph Engine from a collaborative development solution like Beacon?

    Platforms like Beacon offer integrated and collaborative development/deployment environments so that firms can be more efficient in managing and deploying complex code bases. In contrast, Julius Graph Engine attacks the problem from its root by dramatically reducing the amount of coding and efforts required for building complex systems, by taking advantage of the graph computing and the low code RuleDSL. Using Julius Graph Engine, there is a much less need for sophisticated collaborative development tools, as there is much less code to write and manage.

1. How does Julius Graph Engine's RuleDSL and computation DAG differ from Excel's worksheet formula and its dependency graph?

    Julius RuleDSL is much more generic and expressive than Excel's worksheet formulae. The RuleDSL supports both type and value based polymorphism, allowing sophisticated logic to be expressed succinctly. In comparison, Excel formulas are hard coded with specific cell or range. An Excel workbook often has thousands of formulae created by copy/paste, which is error prone and difficult to audit and change. 

    In addition, the Julius Graph Engine is much more performant and scalable than Excel, it can handle large volume of data and computation by running in parallel on many computers. Therefore Julius can be a production solution for enterprise systems, while Excel is mainly a personal and office application.

2. How does Julius Graph Engine differ from other software packages that also use computational DAGs, such as Dask, Tensorflow and Dagger.jl?

    Julius RuleDSL is specifically designed for efficient creation and execution of computational DAGs. It offers much better performance and scalability, as shown in our [tutorials](https://juliustechco.github.io/JuliusGraph) and [benchmark](https://juliustechco.github.io/JuliusGraph/dev/pages/t007_benchmark.html). In addition, Julius RuleDSL is low-code, it requires much less code and efforts to implement the same functionality than using other tools.


### Development Environment
1. What IDE does Julius support?

    Since RuleDSL is just regular code, developers are free to their preferred IDEs. Jupyter lab/notebook and VScode are the most popular choices when working with Julius Graph Engine. 

2. How do I debug a large computational DAG?

    Julius offers great tools for debugging. Using Julius web UI, a developer can quickly navigate and visualize every intermediate results in the computational DAG, allowing quickly track down of bugs to individual nodes. Julius provides an API call for a developer to download the entire state (including data and Atom) of any node in the distributed DAG, and recreate the error conditions on his/her local computer. Then the developer can use a debugger on local computer to step through the execution to pin down the error. 

3. What if there is an error in the computational DAG?

    Julius offers great error handling and recovery capabilities. When there is an error, the web UI will highlight the node with the error and bring a user to the node with one click. By default, the DAG execution will halt until the error is corrected. Julius also supports a trigger mechanism that allows errors to be automatically reported and handled, so that the DAG execution can proceed with errors.


