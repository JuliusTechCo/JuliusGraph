<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1 Quick Start · Julius GraphEngine Tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Julius GraphEngine Tutorials</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="t001_quickstart.html">1 Quick Start</a><ul class="internal"><li><a class="tocitem" href="#How-to-use-this-tutorial-1"><span>How to use this tutorial</span></a></li><li><a class="tocitem" href="#Introduction-1"><span>Introduction</span></a></li><li><a class="tocitem" href="#.-Atoms-1"><span>1. Atoms</span></a></li><li><a class="tocitem" href="#.-Rules-1"><span>2. Rules</span></a></li><li><a class="tocitem" href="#.-Runtime-and-GraphData-1"><span>3. Runtime and GraphData</span></a></li><li><a class="tocitem" href="#.-Exercise-1"><span>4. Exercise</span></a></li></ul></li><li><a class="tocitem" href="t002_machinelearning.html">2 Machine Learning</a></li><li><a class="tocitem" href="t003_mapreduce.html">3 MapReduce</a></li><li><a class="tocitem" href="t004_distributedml.html">4 Distributed Machine Learning</a></li><li><a class="tocitem" href="t005_aad.html">5 Adjoint Algorithmic Differentiation (AAD)</a></li><li><a class="tocitem" href="t006_persist.html">6 ML Experiment Tracking and Persisting</a></li><li><a class="tocitem" href="t007_benchmark.html">7 Graph Computing Benchmark</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="t001_quickstart.html">1 Quick Start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="t001_quickstart.html">1 Quick Start</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliusTechCo/Tutorials/blob/main/src/quickstart.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-1:-Quick-Start-1"><a class="docs-heading-anchor" href="#Tutorial-1:-Quick-Start-1">Tutorial 1: Quick Start</a><a class="docs-heading-anchor-permalink" href="#Tutorial-1:-Quick-Start-1" title="Permalink"></a></h1><h2 id="How-to-use-this-tutorial-1"><a class="docs-heading-anchor" href="#How-to-use-this-tutorial-1">How to use this tutorial</a><a class="docs-heading-anchor-permalink" href="#How-to-use-this-tutorial-1" title="Permalink"></a></h2><ul><li>This tutorial is also available in Jupyter notebook format. To access and run the Jupyter notebook version of the tutorial, please sign up for free developer access by following instructions at <a href="https://github.com/juliustechco/juliusgraph">https://github.com/juliustechco/juliusgraph</a>.</li><li>Additional resources (video demos &amp; blogs) are available at <a href="http://juliustech.co">http://juliustech.co</a>.</li><li>To report bugs or request new features, please raise an issue <a href="https://github.com/JuliusTechCo/JuliusGraph/issues">here</a>. To schedule a live demo, please go to <a href="http://juliustech.co">http://juliustech.co</a>. Please check out this <a href="https://github.com/JuliusTechCo/JuliusGraph/blob/main/FAQ.md">FAQ</a> page or email us at info@juliustech.co for other general inquiries.</li></ul><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p>Julius is an auto-scaling, low-code, and visual graph computing solution that can build sophisticated data and analytical pipelines with very little code. This tutorial is a quick start guide on the basic concepts and programming API of the Julius Graph Engine. You can find introductory videos and blogs on graph computing at <a href="http://juliustech.co">http://juliustech.co</a> if you are new to the subject.</p><p>Julius Graph Engine is implemented in <a href="https://julialang.org/">Julia</a> programming language. Prior knowledge of Julia is not required to follow this tutorial, as developers mainly interact with Julius GraphEngine through the Julius RulesDSL (a domain specific language), which uses only a small subset of Julia syntax. If you have programming experience in Python or Matlab, you can follow this guide without much difficulty. We will highlight and explain the key Julia specific syntax in this tutorial for Python/Matlab developers.</p><p>This tutorial is organized around three key concepts in Julius Graph Engine: Atoms, Rules and Runtime.</p><h2 id=".-Atoms-1"><a class="docs-heading-anchor" href="#.-Atoms-1">1. Atoms</a><a class="docs-heading-anchor-permalink" href="#.-Atoms-1" title="Permalink"></a></h2><p><code>Atom</code> is an abstract Julia type. It is the most fundamental building block of the Julius Graph Engine and denotes atomic operations. The name <code>Atom</code> is chosen because they represents the minimum unit of distribution and caching in the Julius Graph Engine. Atoms cannot be broken apart further for those purposes. The <code>Atom</code> interface enables the Julius Graph Engine to access functionalities implemented in existing software libraries. <code>Atom</code>s can be implemented in all mainstream programming languages, such as Python, C/C++, Java, .Net, R and Julia etc. Existing functions written in these languages can be easily wrapped up under the <code>Atom</code> interface and used in the Julius Graph.</p><p>There are several different subtypes of Atoms for different use cases. We first introduce <code>Datom</code>, which is the most generic <code>Atom</code> type that encapsulates any numerical or data operation. The <code>Datom</code> interface only exposes a single method called <code>fwddata!</code>. The <code>...</code> syntax in the function signature is a Julia specific syntax for catching a varying number of arguments. A subtype of <code>Datom</code> must override this method to implement its specific data or analytical algorithms.</p><pre><code class="language-julia">fwddata!(self::Datom, xs...)</code></pre><p>The <code>fwddata!</code> method can take any number of input data objects in <code>xs</code> and <strong>must return a vector</strong> of output objects. An Atom can return multiple objects in the return vector.</p><p>The following code snippets create a <code>Datom</code> that computes the weighted sum of an input vector of <code>DataFrame</code> objects. <code>DataFrame</code> is the popular choice for representing tabular data in data science applications. Julia&#39;s <code>DataFrame</code> provides similar functionalities as Python pandas Dataframe. A developer is free to choose other input/output types for writing their own <code>Datoms</code>, as the <code>xs</code> in the <code>fwddata!</code> can be any data type.</p><p>The following cells contain a complete implementation of the weighted sum <code>Datom</code>.</p><pre><code class="language-julia">using DataFrames, Base.CoreLogging
using GraphEngine: RuleDSL, GraphVM # RuleDSL package has all the APIs and type definitions of Julius Graph Engine
using GraphIO

# turn off information logging output, only show errors and warning
disable_logging(CoreLogging.Info)

# this method needs to be extended when declaring new datoms
import GraphEngine.RuleDSL: fwddata!

struct WSumDF &lt;: RuleDSL.Datom
    weights::Vector{Float64}
end

function fwddata!(self::WSumDF, dfs::DataFrame...)
    @assert length(dfs) == length(self.weights) &amp;&amp; length(dfs) &gt; 0 &quot;invalid input size&quot;
    sum = self.weights[1] .* dfs[1]

    for i=2:length(self.weights)
        sum .+= (self.weights[i] .* dfs[i])
    end

    return [sum] # must return a vector
end</code></pre><pre><code class="language-none">fwddata! (generic function with 24 methods)</code></pre><p>Next, we show how to use <code>Datom</code> to compute the weighted sum of <code>DataFrame</code>s.</p><pre><code class="language-julia">using Random

ws = [1.0; 2.0; 3.0]
xlen = 10
xs = [rand(xlen), rand(xlen), rand(xlen)]

wsumd = WSumDF(ws)
dfs = [DataFrame(v=x) for x in xs] # create 3 data frames
ysd = RuleDSL.fwddata!(wsumd, dfs...)
first(ysd)</code></pre><div class="data-frame"><p>10 rows × 1 columns</p><table class="data-frame"><thead><tr><th></th><th>v</th></tr><tr><th></th><th title="Float64">Float64</th></tr></thead><tbody><tr><th>1</th><td>2.33398</td></tr><tr><th>2</th><td>1.58804</td></tr><tr><th>3</th><td>3.03259</td></tr><tr><th>4</th><td>3.09591</td></tr><tr><th>5</th><td>4.7524</td></tr><tr><th>6</th><td>3.94189</td></tr><tr><th>7</th><td>1.66798</td></tr><tr><th>8</th><td>3.02437</td></tr><tr><th>9</th><td>1.76869</td></tr><tr><th>10</th><td>4.36206</td></tr></tbody></table></div><p>The Julius Graph Engine offers a convenient macro <code>RuleDSL.@datom</code> for writing new datoms, such that the same weighted sum datom can be implemented more compactly. The <code>RuleDSL.@datom</code> macro translates the code below to a code block similar to the <code>WSumDF</code> implementation above. The two versions are equivalent to each other in functionality. Besides making the code more compact and easier to read and write, <code>RuleDSL.@datom</code> is also future proof, in that the macro would automatically generate conversion code in case of future Julius API changes. Therefore, it is strongly recommended to use the <code>RuleDSL.@datom</code> macro to declare new <code>Datom</code> types.</p><pre><code class="language-julia"># `WSumDF2` is the name of `Datom`&#39;s type
RuleDSL.@datom WSumDF2 begin
    weights::Vector{Float64} # the member of WSumDF2

    function fwddata!(dfs::DataFrame...) # self::WSumDF2 is automatically inserted as the first argument
        sum = zeros(nrow(dfs[1]))
        for (w, df) in zip(weights, dfs) # here weights is translated to self.weights, accessing the member
            sum .+= w .* df[!, 1]
        end
        return [DataFrame(; wsum=sum)] # return a vector
    end
end

wsumd2 = WSumDF2(ws)
ysd2 = RuleDSL.fwddata!(wsumd2, dfs...)

# Horizontally concatenate data frames for comparison
hcat(ysd..., ysd2...; makeunique=true)</code></pre><div class="data-frame"><p>10 rows × 2 columns</p><table class="data-frame"><thead><tr><th></th><th>v</th><th>wsum</th></tr><tr><th></th><th title="Float64">Float64</th><th title="Float64">Float64</th></tr></thead><tbody><tr><th>1</th><td>2.33398</td><td>2.33398</td></tr><tr><th>2</th><td>1.58804</td><td>1.58804</td></tr><tr><th>3</th><td>3.03259</td><td>3.03259</td></tr><tr><th>4</th><td>3.09591</td><td>3.09591</td></tr><tr><th>5</th><td>4.7524</td><td>4.7524</td></tr><tr><th>6</th><td>3.94189</td><td>3.94189</td></tr><tr><th>7</th><td>1.66798</td><td>1.66798</td></tr><tr><th>8</th><td>3.02437</td><td>3.02437</td></tr><tr><th>9</th><td>1.76869</td><td>1.76869</td></tr><tr><th>10</th><td>4.36206</td><td>4.36206</td></tr></tbody></table></div><p>We also define another <code>Datom</code> type <code>RandDF</code> that returns uniform random numbers in a <code>Dataframe</code> for later use. The <code>meanv</code> parameter specifies the mean of the uniform random numbers.</p><pre><code class="language-julia">RuleDSL.@datom RandDF begin
    n::Int
    meanv::Float64

    function fwddata!()
        return [DataFrame(v=(rand(n) .- 0.5 .+ meanv))] # create a random vector
    end
end</code></pre><pre><code class="language-none">fwddata! (generic function with 26 methods)</code></pre><h2 id=".-Rules-1"><a class="docs-heading-anchor" href="#.-Rules-1">2. Rules</a><a class="docs-heading-anchor-permalink" href="#.-Rules-1" title="Permalink"></a></h2><p>The <code>Atom</code> and its subtype <code>Datom</code> are generic abstractions for atomic numerical and data processing algorithms. However, just having atoms is not enough to build a working system or application, as we still need to pipeline the atoms in a meaningful way. The RuleDSL is a high level domain specific language (DSL) designed exactly for that purpose. The RuleDSL specifies precisely how atoms should be connected to one another to form a computation DAG (directed acyclic graph) for the entire system.</p><p>The RuleDSL is a graph programming language, and has a very limited syntax designed specifically for creating DAGs. It doesn&#39;t support most constructs in conventional programming languages such as variables, functions, branches, loops or inheritance. The RuleDSL only contains declarations of discrete rules, so it is much easier to learn and use in practice. The <code>Atom</code> is an interface to traditional programming languages and libraries. The combination of Rules and Atoms is extremely powerful and expressive, and they offer the best of traditional and graph programming. Together they can build systems of any scale and complexity with minimal amounts of code.</p><h3 id=".1-RuleDSL-Syntax-1"><a class="docs-heading-anchor" href="#.1-RuleDSL-Syntax-1">2.1 RuleDSL Syntax</a><a class="docs-heading-anchor-permalink" href="#.1-RuleDSL-Syntax-1" title="Permalink"></a></h3><p>We use a Fibonacci sequence as an example to describe the RuleDSL syntax. The following is a Fibonacci like sequence using the <code>WSumDF</code> datom we just defined. This example is different from the classic Fibonacci sequence in that its two initial terms are random vectors instead of scalars 0 and 1; thus the recursive summation is applied to random vectors instead of scalars.</p><pre><code class="language-julia">RuleDSL.@addrules seq begin
    fib(n::Int) = RuleDSL.Alias(fib(n, Val(n &lt;= 1))) # binds the 2nd parameter for convenience, Alias is an atom that passes the outputs of other rules

    fib(f::Float64) = RuleDSL.Alias(fib(Int(floor(f)))) # adapting rule for a floating point parameter

    fib(n::Int, isend::Val{false}) = begin # defines the recursion of Fibonacci sequence
        WSumDF[[1.0, 1.0]](fib(n - 1, Val(n &lt;= 2)), fib(n - 2, Val(n &lt;= 3)))
    end

    fib(n::Int, isend::Val{true}) = RandDF[10, Float64(n)]() # using the RandDF atom defined earlier, random vector of length 10.
end</code></pre><p>The <code>RuleDSL.@addrules</code> is a macro provided by the Julius Graph Engine for writing rules using the RuleDSL. The first argument <code>seq</code> is a user defined namespace to help organize related rules, followed by a list of discrete rules between the <code>begin</code> and <code>end</code>. There are four rules defined in the above declarations, the basic syntax of individual rules are:</p><pre><code class="language-julia">rulename(arg1::Type1, arg2::Type2, ...) = AtomName[a1, a2, a3...](deprule1(args1...), deprule2(args2...), ...)</code></pre><p>For example, in the rule:</p><pre><code class="language-julia">fib(n::Int, isend::Val{false}) = WSumDF[[1.0, 1.0]](fib(n - 1, Val(n &lt;= 2)), fib(n - 2, Val(n &lt;= 3)))</code></pre><ul><li><code>fib</code> is the rule name, the full name of a rule includes its namespace, in this case it   is <code>seq.fib</code></li><li><code>n</code> and <code>isend</code> are two parameters to this rule, with type <code>Int, Val{false}</code>, all rule parameters must have corresponding types in the rule declarations. The <code>Val{false}</code> is a Julia templatized type that enables value based pattern matching (matching the value <code>false</code> in this case).</li><li><code>WSumDF</code> is the atom name which was defined earlier, the outer square bracket encloses the parameter to the atom&#39;s constructor</li><li><code>[1.; 1.]</code> in the square bracket is the parameter to the Datom <code>WSumDF</code>&#39;s constructor, i.e., it binds to the weights parameter. The <code>WSumDF[[1.; 1.]]</code> in the rule declaration is directly translated to a constructor call of <code>WSumDF([1.; 1.])</code> to create the <code>WSumDF</code> object at run time.</li><li>the <code>fib(n-1, Val(n&lt;=2)), fib(n-2, Val(n&lt;=3))</code> inside the parenthesis is a list of dependent rules, each of which must map to existing rules, so that the Graph Engine can recursively expand the rules at run time to create a complete computational graph. A rule can refer to other rules (including itself) as dependencies. In this example, it refers to the same rule as dependency to define the recursive sum of the Fibonacci sequence.</li></ul><p>Besides the Datom <code>WSumDF</code> we have just defined, these <code>seq.fib</code> rules also use the Atoms defined in the <code>GraphEngine.RuleDSL</code> package, such as <code>RuleDSL.Alias</code>. The Julius Graph Engine comes with a rich set of pre-built Atoms that can be used by referring to their full Atom names. The atom <code>RuleDSL.Alias</code> is a special atom that simply passes the results of the dependent rules; it creates an additional rule name to improve readability. The Alias atom is often used for binding certain rule parameters to concrete values, as shown in the first <code>seq.fib</code> rule above.</p><h3 id=".2-Polymorphism-and-Rule-Matching-1"><a class="docs-heading-anchor" href="#.2-Polymorphism-and-Rule-Matching-1">2.2 Polymorphism and Rule Matching</a><a class="docs-heading-anchor-permalink" href="#.2-Polymorphism-and-Rule-Matching-1" title="Permalink"></a></h3><p>The RulesDSL supports multiple dispatch with type and value based polymorphism. As a result it can express complex and dynamic data transformation or analytical logic. Multiple rules can have the same name but different argument types. For example we have four rules of <code>seq.fib</code> with different parameter types above. At run time, the rule with the most precise parameter type match is invoked to create a node in the graph, and this process continues recursively until all the dependent nodes are created in the graph. The final result of this rule matching and expansion process is a full computational graph (a DAG), which is ready for execution.</p><p>The value based polymorphism is supported using Julia&#39;s templatized type, such as <code>Val{true}</code> or <code>Val{false}</code>. For example, in the first <code>seq.fib</code> rule above, if <code>n &lt;= 1</code>, the isend parameter of the dependent rules become an instance of the type <code>Val{true}</code>, which would match to the last <code>seq.fib</code> rule governing the initial terms.</p><p>To fully understand this process, let&#39;s go through the creation of a computational graph for <code>seq.fib(3.2)</code> step by step. We first create then run the computational graph for <code>seq.fib(3.2)</code>.</p><pre><code class="language-julia"># RuleDSL.@ref is a macro to create a concrete instance to a rule
ref = RuleDSL.@ref seq.fib(3.2)

# configuration object to pass common parameters to run time
config = RuleDSL.Config()

# run the computation according to the defined rules to create output in the Set
gs = GraphVM.createlocalgraph(config, RuleDSL.GenericData());
GraphVM.calcfwd!(gs, Set([ref]));</code></pre><p>Julius Graph Engine provides an intuitive web UI to visualize and interact with the resulting computational graph, the following cell shows the resulting DAG and a link for the interactive web UI, where a user can access the entire calculation with all the intermediate results.</p><pre><code class="language-julia"># override label display on the node to show additional rule parameters
# user can override the nodelabel function to customize the labels on the nodes
import GraphEngine.RuleDSL: nodelabel
function nodelabel(::AbstractGraphState, ref::NodeRef)
    hdr = &quot;$(ref.ns).$(ref.name)&quot;
    ps = join(simplerepr.(ref.params), &quot;, &quot;)

    return &quot;$hdr($ps)&quot;
end

# start a local data server that feeds data to the web UI
gss = Dict{String,RuleDSL.AbstractGraphState}()
port = GraphVM.drawdataport()
@async GraphVM.startresponder(gss, port)

svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true, key=&quot;fib&quot;);
GraphIO.postsvg(svg, &quot;quickstart_1.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/ui/depgraph.html?dataurl=127.0.0.1:7752_fib
starting data service at port 7752
</code></pre><p align = "center">
<img src="../assets/quickstart_1.svg" alt="" title="Fib"/>
</p>
<p align = "center">
Figure 1 - Fibonacci
</p><p>In this example, the steps to create the entire computation DAG includes:</p><ol><li>The best matching rule for <code>seq.fib(3.2)</code> is <code>fib(f::Float64)=RuleDSL.Alias(fib(Int(floor(f))))</code>, which is aliased to <code>seq.fib(3)</code> because the parameter <code>Int(floor(f))</code> in the dependent rule evaluates to 3.</li><li>The best matching rule for <code>seq.fib(3)</code> is <code>fib(n::Int)=RuleDSL.Alias(fib(n, Val(n&lt;=1)))</code>, whose dependent rule is <code>seq.fib(3, Val(false))</code> where <code>Val(false)</code> is an instance of templatized type <code>Val{false}</code>.</li><li>The best matching rule for <code>seq.fib(3, Val(false))</code> is  <code>fib(n::Int, isend::Val{false})=WSumDF[[1.; 1.]](fib(n-1, Val(n&lt;=2)), fib(n-2, Val(n&lt;=3)))</code>, with two dependent rules: <code>seq.fib(2, Val(false))</code> and <code>seq.fib(1, Val(true))</code> .</li><li>The best matching rule for <code>seq.fib(2, Val(false))</code> is again  <code>fib(n::Int, isend::Val{false})=WSumDF[[1.; 1.]](fib(n-1, Val(n&lt;=2)), fib(n-2, Val(n&lt;=3))</code>, with two dependent rules <code>seq.fib(1, Val(true))</code>  and <code>seq.fib(0, Val(true))</code></li><li>The best matching rule for <code>seq.fib(1, Val(true))</code> and <code>seq.fib(0, Val(true))</code> is <code>fib(n::Int, isend::Val{true})=RandDF[10, Float64(n)]()</code>, which do does not have any further dependencies. Now the graph expansion/creation is complete.</li></ol><p>From this expansion process, the nodes created in the graph are essentially rules binded with concrete rule parameters. Nodes in the graph are represented by a <code>ReleDSL.NodeRef</code> type, which is nothing but a reference to the underlying rule and a list of its rule parameters. The nodes are guaranteed to be unique in a graph, i.e., there can&#39;t be multiple nodes with identical underlying rule and parameters in a graph. The hash value of <code>RuleDSL.NodeRef</code> object is often used as a unique identifier for nodes in the graph. Therefore, the relationship between rules, nodes and their hash are:</p><p>rule in RuleDSL $ \xrightarrow{\text{bind to concrete rule parameters}} $ node in graph as <code>RuleDSL.NodeRef</code> $ \xrightarrow{\text{hash}} $ unique node ID</p><p>All the intermediate results of executing a computational DAG are held in a <code>gs</code> object, which is of type <code>GraphVM.GraphState</code>. The result of every node can be retrieved using the <code>getdata</code> method with the hash value of the corresponding <code>RuleDSL.NodeRef</code> object.</p><p>The <code>RuleDSL.@ref</code> is a convenient macro for creating <code>RuleDSL.NodeRef</code> from a rule. The following cells show how two <code>RuleDSL.NodeRef</code> objects can be created from the same rule but with different parameters thus having different hash IDs. Both of their values can be retrieved by <code>getdata</code>.</p><pre><code class="language-julia">fib2 = RuleDSL.@ref seq.fib(2, Val(false))
fib3 = RuleDSL.@ref seq.fib(3, Val(false))

println(typeof(fib2) =&gt; hash(fib2))
println(typeof(fib3) =&gt; hash(fib3))

v2 = RuleDSL.getdata(gs, hash(fib2))
v3 = RuleDSL.getdata(gs, hash(fib3))

hcat(v2..., v3...; makeunique=true)</code></pre><div class="data-frame"><p>10 rows × 2 columns</p><table class="data-frame"><thead><tr><th></th><th>v</th><th>v_1</th></tr><tr><th></th><th title="Float64">Float64</th><th title="Float64">Float64</th></tr></thead><tbody><tr><th>1</th><td>0.970256</td><td>1.7066</td></tr><tr><th>2</th><td>0.718173</td><td>1.69931</td></tr><tr><th>3</th><td>0.901956</td><td>1.88341</td></tr><tr><th>4</th><td>1.33865</td><td>2.44973</td></tr><tr><th>5</th><td>0.575761</td><td>1.08489</td></tr><tr><th>6</th><td>0.138334</td><td>0.684488</td></tr><tr><th>7</th><td>1.48498</td><td>2.89077</td></tr><tr><th>8</th><td>1.37087</td><td>2.5743</td></tr><tr><th>9</th><td>0.898616</td><td>2.28308</td></tr><tr><th>10</th><td>0.866972</td><td>2.15134</td></tr></tbody></table></div><h3 id=".3-Dynamic-Dependency-1"><a class="docs-heading-anchor" href="#.3-Dynamic-Dependency-1">2.3 Dynamic Dependency</a><a class="docs-heading-anchor-permalink" href="#.3-Dynamic-Dependency-1" title="Permalink"></a></h3><p>A rule&#39;s dependency can be dynamic, i.e., the number and type of dependencies can be different according to the rule&#39;s parameters. For example the following cell defines a sum of all the even terms in the Fibonacci sequence:</p><pre><code class="language-julia">RuleDSL.@addrules seq begin
    sumeven(n::Int) = begin
        WSumDF[fill(1.0, length(0:2:n))](RuleDSL.@ref(fib(i) for i in 0:2:n)...)
    end
end</code></pre><p>The <code>RuleDSL.@ref(fib(i) for i in 0:2:n)</code> above creates a vector of <code>RuleDSL.NodeRef</code> object from the list comprehension inside. The <code>...</code> is a special syntax in rule dependency that signals dynamic rule dependencies, it can follow any valid Julia expression or functions that returns an instance or a vector of RuleDSL.NodeRef.</p><pre><code class="language-julia">RuleDSL.@ref seq.fib(5)</code></pre><pre><code class="language-none">seq:fib/5</code></pre><pre><code class="language-julia">RuleDSL.@ref(seq.fib(i) for i in 0:2:5)</code></pre><pre><code class="language-none">3-element Vector{GraphEngine.RuleDSL.NodeRef}:
 seq:fib/0
 seq:fib/2
 seq:fib/4</code></pre><p>The results of the dynamic dependency are shown in the graph below.</p><pre><code class="language-julia"># create a concrete instance to a rule
sumeven = RuleDSL.@ref seq.sumeven(5)

# run the computation according to the defined rules to create the desired output
gs = GraphVM.createlocalgraph(config, RuleDSL.GenericData());
GraphVM.calcfwd!(gs, Set([sumeven])); # we want to compute sumeven

svg = GraphIO.postlocalgraph(gss, gs, port, true; key=&quot;even&quot;);
GraphIO.postsvg(svg, &quot;quickstart_2.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/ui/depgraph.html?dataurl=127.0.0.1:7752_even
</code></pre><p align = "center">
<img src="../assets/quickstart_2.svg" alt="" title="Dynamic Dependency"/>
</p>
<p align = "center">
Figure 2 - Dynamic Dependency
</p><h3 id=".4-Multi-line-Rule-1"><a class="docs-heading-anchor" href="#.4-Multi-line-Rule-1">2.4 Multi-line Rule</a><a class="docs-heading-anchor-permalink" href="#.4-Multi-line-Rule-1" title="Permalink"></a></h3><p>So far, all rules we have shown are single line declarations. Sometimes it is convenient to run simple calculations or data transformations when declaring a rule.  Multi-line declarations is allowed by wrapping them up within <code>begin ... end</code> , as shown in the following example of an equivalent declaration of rule <code>seq.sumeven(n::Int)</code>. The rule can be easier to read using the local variables <code>dep, ws</code>:</p><pre><code class="language-julia">RuleDSL.@addrules seq begin
    sumeven2(n::Int) = begin
        deps = RuleDSL.@ref(fib(i) for i in 0:2:n)
        ws = fill(1.0, length(deps))
        WSumDF[ws](deps...)
    end
end</code></pre><h2 id=".-Runtime-and-GraphData-1"><a class="docs-heading-anchor" href="#.-Runtime-and-GraphData-1">3. Runtime and GraphData</a><a class="docs-heading-anchor-permalink" href="#.-Runtime-and-GraphData-1" title="Permalink"></a></h2><p>The combination of Rules and Atoms are extremely powerful and expressive. They can build any data and analytical pipeline as a directed acyclic graph (DAG) regardless of its complexity, with minimal coding in the RuleDSL. However, a system needs additional runtime configurations to function properly. Runtime configuration is an important aspect of system building, which is the topic of this section.</p><p>Runtime configuration usually includes the following attributes:</p><ul><li>Distribution: whether a system is running on a local computer or a distributed computing environment</li><li>Caching: should the intermediate results being cached, and how/where it is cached</li><li>Adjoint Algorithmic Differentiation (AAD): whether the system execution includes AAD</li><li>Batch or Streaming: whether the system is running once in batch mode, or running in live mode with continuous streaming data</li></ul><p>In a traditional development environment, separate and duplicated codebases are created in order to support different runtimes. For example, it is common for a bank to have separate and dedicated systems for each combination of (runtime, applications), such as an end of day batch system for Macro trading, a live intraday system for Equity e-trading, a test/UAD environment for XVA, etc. These specialized and dedicated systems often have different software, hardware and configurations. As a result, the number of these specialized systems can quickly multiply and drive up the overall complexity and support cost, while at the same time hurt the firm&#39;s overall consistency and reliability.</p><p>The Julius Graph Engine provides a number of common runtime configurations out of the box. Different runtime environments can be created on-demand from a common set of Rules and Atoms that define the business logic. This removes the need for duplicated implementation of runtime configurations for individual systems, leading to a significant reduction in support cost and system complexity.</p><p>The Julius Runtimes are implemented as different <code>GraphData</code> types. In the previous sections, we have already seen the <code>GenericData</code> in action, which is a derived type of <code>GraphData</code>. The following table shows some of the most common <code>GraphData</code> configurations in Julius:</p><table><tr><th style="text-align: center">GraphData Type</th><th style="text-align: center">Caching</th><th style="text-align: center">Batch/Stream</th><th style="text-align: center">support AAD</th><th style="text-align: center">supported Atom type</th><th style="text-align: center">Distribution</th></tr><tr><td style="text-align: center"><code>RuleDSL.GenericData</code></td><td style="text-align: center">yes</td><td style="text-align: center">batch</td><td style="text-align: center">no</td><td style="text-align: center">any</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: center"><code>RuleDSL.NumericalData</code></td><td style="text-align: center">yes</td><td style="text-align: center">batch</td><td style="text-align: center">yes</td><td style="text-align: center"><code>Quantom</code> only</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: center"><code>RuleDSL.StreamData</code></td><td style="text-align: center">no</td><td style="text-align: center">stream</td><td style="text-align: center">no</td><td style="text-align: center">any</td><td style="text-align: center">yes</td></tr></table><p>Any <code>GraphData</code> can be used in either local or distributed mode. We only work with a local runtime in this notebook, but subsequent tutorials will show the distributed setup. The <code>NumericalData</code> is a <code>GraphData</code> specialized for numerical computations with AAD, which we will cover in another tutorial.</p><p>Next, we will show how streaming use cases can be easily created using the <code>StreamData</code>.</p><h3 id=".1-Streaming-1"><a class="docs-heading-anchor" href="#.1-Streaming-1">3.1 Streaming</a><a class="docs-heading-anchor-permalink" href="#.1-Streaming-1" title="Permalink"></a></h3><p>Streaming is a common runtime use case, e.g., for live intraday pricing and risk of a trading desk. With the <code>RuleDSL.StreamData</code> runtime, Julius can turn any computational graph into a streaming system with a few lines of code changes.</p><p>In the following few cells, we take the Fibonacci sequence as defined above, which operates in the batch mode, and turn it into a streaming processing. Its initial inputs, the <code>fib(0)</code>  and <code>fib(1)</code> terms, become the streaming input of random vectors.</p><p>To show the effects of streaming, we create a new <code>Datom</code> that computes the running average of all the streamed input Dataframes.</p><pre><code class="language-julia"># computes the running average of all the value being streamed
RuleDSL.@datom StreamAverage begin
    sum::DataFrame = DataFrame()
    cnt::Vector = [0]

    function fwddata!(x::DataFrame)
        if cnt[1] == 0
            append!(sum, x)
        else
            sum .+= x
        end

        cnt[1] += 1
        [ sum ./ cnt[1] ]
    end
end</code></pre><pre><code class="language-none">fwddata! (generic function with 27 methods)</code></pre><p>Then we define a generic rule for computing stream average from any node. One of the most powerful features of Julius Rules DSL is the high order rule, which is a rule declaration that takes a <code>RuleDSL.NodeRef</code> object as parameter.  A high order rule can declare a generic pattern that is applicable to any node in a graph. We will cover high order rules in more detail in a later map/reduce tutorial.</p><p>In the following high order rule for stream average, the <code>...</code> operator in the dependency indicates dynamic dependency, which is just the input node as defined by the <code>NodeRef</code> parameter. The <code>seq.streamaverage</code> is therefore a generic operation that can be applied to any other node as defined in its argument <code>ref</code>.</p><pre><code class="language-julia">RuleDSL.@addrules seq begin
    streamaverage(ref::RuleDSL.NodeRef) = StreamAverage(ref...)
end

# sources of streaming inputs
srcs = [
    RuleDSL.@ref(seq.fib(0, Val(true))), RuleDSL.@ref(seq.fib(1, Val(true)))
]
sd = RuleDSL.StreamData(Set(hash.(srcs)), 1) # create StreamData with queue buffer length of 1

ref = RuleDSL.@ref seq.fib(5)
savg = RuleDSL.@ref seq.streamaverage(ref)

gs2 = GraphVM.createlocalgraph(config, sd) # create a graph using StreamData
GraphVM.calcfwd!(gs2, Set{NodeRef}(savg)); # set up the pipeline of streaming</code></pre><p>The calcfwd! call above builds up streaming pipelines between nodes. In streaming mode, the connection between nodes in the graph are message queues, where each node runs asynchronously to process the message from the input queue, and then puts the results into the output queue.</p><p>The following cell streams 20,000 different initial inputs, which are randomly drawn by the datom <code>RandDF</code>. Since the final output&#39;s atom is StreamAverage, which computes the running average of all the streamed data, the net result is essentially to calculate the Fibonnaci sequence using a Monte Carlo simulation of 20,000 paths, and the results are all close to 5, which is the correct value of the 5th term of the classic Fibonacci sequence.</p><p>Unlike the mini-batch streaming processing in Spark, the streaming implementation in Julius is fully pipelined, where different nodes are processing different streaming inputs concurrently at any given time. As a result, Julius streaming is extremely fast, achieving more than 10,000 messages per second.</p><pre><code class="language-julia">@time RuleDSL.pushpullcalc!(gs2, 10000) # stream 10,000 messages, this call can be made multiple times to stream more data
@time RuleDSL.pushpullcalc!(gs2, 10000)
avg = RuleDSL.getdata(gs2, hash(savg))[1] # [1] is because the output is a vector of 1</code></pre><div class="data-frame"><p>10 rows × 1 columns</p><table class="data-frame"><thead><tr><th></th><th>v</th></tr><tr><th></th><th title="Float64">Float64</th></tr></thead><tbody><tr><th>1</th><td>5.00215</td></tr><tr><th>2</th><td>5.01247</td></tr><tr><th>3</th><td>4.98262</td></tr><tr><th>4</th><td>5.00137</td></tr><tr><th>5</th><td>5.0158</td></tr><tr><th>6</th><td>5.00704</td></tr><tr><th>7</th><td>5.00342</td></tr><tr><th>8</th><td>5.0053</td></tr><tr><th>9</th><td>5.00642</td></tr><tr><th>10</th><td>5.01311</td></tr></tbody></table></div><p>Once we are done with streaming, we can tear down the streaming pipeline by calling <code>stopstream!</code> on <code>StreamData</code> to reclaim the resources. Once <code>stopstream!</code> is called, it will no longer accept any more incoming streaming data.</p><pre><code class="language-julia">RuleDSL.stopstream!(sd);</code></pre><pre><code class="language-julia">GraphVM.servedata(gss, gs2, port; key=&quot;stream&quot;);

# revert back nodelabel to default definition
nodelabel(gs::RuleDSL.AbstractGraphState, ref::RuleDSL.NodeRef)=haskey(ref.meta, :label) ? ref.meta[:label] : &quot;$(ref.ns).$(ref.name)&quot;</code></pre><pre><code class="language-none">nodelabel (generic function with 4 methods)</code></pre><h2 id=".-Exercise-1"><a class="docs-heading-anchor" href="#.-Exercise-1">4. Exercise</a><a class="docs-heading-anchor-permalink" href="#.-Exercise-1" title="Permalink"></a></h2><p>Thanks for your attention! Now that you have learned the basics of the <strong>Julius Graph Engine</strong>, it is time to get your hands dirty and write your own rules and atoms! Here is a suggested exercise:</p><p>Modify the streaming use case above, to also report the calculation of Monte Carlo error, which is the standard deviation of the samples divided by the square root of the number of samples. You can take advantage of the following relationship <span>$\sigma^2(x)=E[x^2] - E^2[x]$</span> by tracking the average of squares. Then the MC error is <span>$\frac{\sigma(x)}{\sqrt{n}}$</span> where <span>$n$</span> is the number of samples streamed.</p><p>There can be different approaches for doing this:</p><ol><li>create a new Datom and corresponding rule, similar to <code>StreamAverage</code> and <code>seq.streamaverage</code>, that computes the running mean and MC error, and returns them as two DataFrames in the output vector, or two columns in the same DataFrame.</li><li>create new Datoms for arithmetic operations like square, subtraction and sqrt on type DataFrame, then compute the MC error by writing new rules that connect these new datoms. You can consider writing a generic high order rule that works for any node and any Julia function. A rule can take a Julia function as a parameter!</li></ol><p>The first approach is quick and fast, while the second approach is more generic and reusable, with the additional benefit of being able to see the intermediate results.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../index.html">« Introduction</a><a class="docs-footer-nextpage" href="t002_machinelearning.html">2 Machine Learning »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 27 April 2022 11:24">Wednesday 27 April 2022</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
