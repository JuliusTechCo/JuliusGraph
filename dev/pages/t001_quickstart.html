<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1 Quick Start · Julius GraphEngine Tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Julius GraphEngine Tutorials</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="t001_quickstart.html">1 Quick Start</a><ul class="internal"><li><a class="tocitem" href="#How-to-use-this-tutorial-1"><span>How to use this tutorial</span></a></li><li><a class="tocitem" href="#.-Introduction-1"><span>0. Introduction</span></a></li><li><a class="tocitem" href="#.-Atoms-1"><span>1. Atoms</span></a></li><li><a class="tocitem" href="#.-Rules-1"><span>2. Rules</span></a></li><li><a class="tocitem" href="#.-Runtime-and-GraphData-1"><span>3. Runtime and GraphData</span></a></li><li><a class="tocitem" href="#.-Exercise-1"><span>4. Exercise</span></a></li></ul></li><li><a class="tocitem" href="t002_titanic.html">2 Machine Learning</a></li><li><a class="tocitem" href="t003_mapreduce.html">3 MapReduce</a></li><li><a class="tocitem" href="t004_bagging.html">4 Distributed Machine Learning Pipeline</a></li><li><a class="tocitem" href="t005_aad.html">5 Adjoint Algorithmic Differentiation (AAD)</a></li><li><a class="tocitem" href="t006_advanced.html">6 Advanced Features</a></li><li><a class="tocitem" href="t007_persist.html">7 MLOps: ML Experiment Tracking and Persisting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="t001_quickstart.html">1 Quick Start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="t001_quickstart.html">1 Quick Start</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliusTechCo/Tutorials/blob/main/src/quickstart.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-1:-Quick-Start-1"><a class="docs-heading-anchor" href="#Tutorial-1:-Quick-Start-1">Tutorial 1: Quick Start</a><a class="docs-heading-anchor-permalink" href="#Tutorial-1:-Quick-Start-1" title="Permalink"></a></h1><h2 id="How-to-use-this-tutorial-1"><a class="docs-heading-anchor" href="#How-to-use-this-tutorial-1">How to use this tutorial</a><a class="docs-heading-anchor-permalink" href="#How-to-use-this-tutorial-1" title="Permalink"></a></h2><ul><li>Select &quot;run all cells&quot; on this notebook from the Run menu in Jupyter notebook or Jupyter lab. This step will produce intermediate data output and charts.</li><li>Some cells print out a url, which you can click on and bring up an interactive web UI to visualize the graph data.</li><li>In the unlikely event that the notebook becomes irresponsive, you can try &quot;Restart Kernel&quot; from the Kernel menu, then run individual cells one by one using <code>Shift+Enter</code>.</li><li>Some tutorials use local clusters consisting of multiple processes to mimic the effects of graph distribution over a remote cluster. By default, these local clusters automatically stop after idling for 15 minutes to conserve CPU and memory resources. You will need to rerun the entire notebook if your local cluster stopped due to inactivity.</li><li>Additional resources (video demos &amp; blogs) are available at http://juliustech.co.</li><li>To report any issues, get help or request features, please raise an issue at https://github.com/JuliusTechCo/JuliusGraph/issues.</li></ul><h2 id=".-Introduction-1"><a class="docs-heading-anchor" href="#.-Introduction-1">0. Introduction</a><a class="docs-heading-anchor-permalink" href="#.-Introduction-1" title="Permalink"></a></h2><p>Julius is an auto-scaling, low-code, and visual graph computing solution, that can build sophisticated data and analytical pipelines with very little code. This tutorial is a quick start guide on the basic concepts and programming API of Julius Graph Engine. You can find introductory videos and blogs on graph computing at http://juliustech.co if you are new to the subject.</p><p>Julius Graph Engine is implemented in <a href="https://julialang.org/">Julia</a>. Prior knowledge in Julia is not required to follow this tutorial, as developer mainly interact with Julius GraphEngine through a domain specific language (DSL): the Julius RulesDSL, which only uses a very limited set of Julia syntax.  If you have programming experience in Python or Matlab, you can follow this guide without much difficulties. We will highlight and explain some key Julia specific syntax in this tutorial for Python/Matlab developers.</p><p>This tutorial is organized around three key concept in Julius Graph Engine: Atoms, Rules and Runtime.</p><h2 id=".-Atoms-1"><a class="docs-heading-anchor" href="#.-Atoms-1">1. Atoms</a><a class="docs-heading-anchor-permalink" href="#.-Atoms-1" title="Permalink"></a></h2><p><code>Atom</code> is an abstract Julia type, it is the most fundamental building block of Julius Graph Engine, it stands for atomic operations. The name <code>Atom</code> is chosen because they are the minimal unit of distribution and caching in Julius Graph Engine, atoms cannot be broken apart further for those purposes. <code>Atom</code> interface enables Julius Graph Engine to access functionalities implemented in existing software libraries. <code>Atom</code> can be implemented in all major programming languages, such as Python, C/C++, Java, .Net, R and Julia etc. Existing functions written in these languages can be easily wrapped up as an atom and be used in Julius Graph.</p><p>There are several different sub types of Atoms for different use cases. We first introduce <code>Datom</code>, which is the most generic <code>Atom</code> type that encapsulates any numerical or data operation. The <code>Datom</code> interface only has a single method called <code>fwddata!</code>. The <code>...</code> syntax in the function signature is a Julia specific syntax for catching varying number of arguments.</p><pre><code class="language-julia">fwddata!(self::Datom, xs...)</code></pre><p>The <code>fwddata!</code> method can take any number of input data object in <code>xs</code> and <strong>must return a vector</strong> of output objects. The return type of vector is chosen to be explicit that the output could contain multiple objects.</p><p>The follow code snippets creates a <code>Datom</code> that computes the weighted sum of an input vector of <code>DataFrame</code> objects. <code>DataFrame</code> is the popular choice for representing tabular data in data science applications. Julia&#39;s <code>DataFrame</code> provides similar functionalities as the Python&#39;s pandas Dataframe. A developer is free to choose other input/output types for writing their own <code>Datoms</code>, the <code>xs</code> in the <code>fwddata!</code> can be any data type.</p><p>The following cells contain a complete implementation of the weighted sum <code>Datom</code>.</p><pre><code class="language-julia">using DataFrames, Base.CoreLogging
using GraphEngine: RuleDSL, GraphVM # RuleDSL package has all the APIs and type definitions of Julius Graph Engine
using GraphIO

# turn off information logging output, only show errors and warning
disable_logging(CoreLogging.Info)

# start a data server for the web UI
gss = Dict{String,RuleDSL.AbstractGraphState}()
port = GraphVM.drawdataport()
@async GraphVM.startresponder(gss, port)</code></pre><pre><code class="language-none">Task (runnable) @0x00007f210df32cb0</code></pre><pre><code class="language-julia"># this method needs to be extended when declaring new datoms
import GraphEngine.RuleDSL: fwddata!

struct WSumDF &lt;: RuleDSL.Datom
    weights::Vector{Float64}
end

function fwddata!(self::WSumDF, dfs::DataFrame...)
    @assert length(dfs) == length(self.weights) &amp;&amp; length(dfs) &gt; 0 &quot;invalid input size&quot;
    sum = self.weights[1] .* dfs[1]

    for i=2:length(self.weights)
        sum .+= (self.weights[i] .* dfs[i])
    end

    return [sum] # must return a vector
end</code></pre><pre><code class="language-none">fwddata! (generic function with 24 methods)</code></pre><p>Next, we show how to use <code>Datom</code> to compute the weighted sum of <code>DataFrame</code>s.</p><pre><code class="language-julia">using Random

ws = [1.0; 2.0; 3.0]
xlen = 10
xs = [rand(xlen), rand(xlen), rand(xlen)]

wsumd = WSumDF(ws)
dfs = [DataFrame(v=x) for x in xs] # create 3 data frames
ysd = RuleDSL.fwddata!(wsumd, dfs...)
first(ysd)</code></pre><div class="data-frame"><p>10 rows × 1 columns</p><table class="data-frame"><thead><tr><th></th><th>v</th></tr><tr><th></th><th title="Float64">Float64</th></tr></thead><tbody><tr><th>1</th><td>1.95608</td></tr><tr><th>2</th><td>4.79308</td></tr><tr><th>3</th><td>1.63038</td></tr><tr><th>4</th><td>5.32593</td></tr><tr><th>5</th><td>3.7549</td></tr><tr><th>6</th><td>2.8901</td></tr><tr><th>7</th><td>3.14794</td></tr><tr><th>8</th><td>3.88091</td></tr><tr><th>9</th><td>1.73055</td></tr><tr><th>10</th><td>3.86106</td></tr></tbody></table></div><p>Julius Graph Engine offers a convenient macro <code>RuleDSL.@datom</code> for writing new datoms, such that he same weighed sum datom can be implemented more compactly as below. The <code>RuleDSL.@datom</code> macro translate the code below to a code block similar to the <code>WSumDF</code> implementation above. The two versions are equivalent to each other in functionality. Besides making the code more compact and easier to read and write, <code>RuleDSL.@datom</code> is also future proof, in that the macro would automatically generate conversion code in case of future Julius API changes. Therefore, it is strongly recommended to use the <code>RuleDSL.@datom</code> macro to declare new <code>Datom</code> types.</p><pre><code class="language-julia"># `WSumDF2` is the name of `Datom`&#39;s type
RuleDSL.@datom WSumDF2 begin
    weights::Vector{Float64} # the member of WSumDF2

    function fwddata!(dfs::DataFrame...) # self::WSumDF2 is automatically inserted as the first argument
        sum = zeros(nrow(dfs[1]))
        for (w, df) in zip(weights, dfs) # here weights is translated to self.weights, accessing the member
            sum .+= w .* df[!, 1]
        end
        return [DataFrame(; wsum=sum)] # return a vector
    end
end

wsumd2 = WSumDF2(ws)
ysd2 = RuleDSL.fwddata!(wsumd2, dfs...)

# Horizontally concatenate data frames for comparison
hcat(ysd..., ysd2...; makeunique=true)</code></pre><div class="data-frame"><p>10 rows × 2 columns</p><table class="data-frame"><thead><tr><th></th><th>v</th><th>wsum</th></tr><tr><th></th><th title="Float64">Float64</th><th title="Float64">Float64</th></tr></thead><tbody><tr><th>1</th><td>1.95608</td><td>1.95608</td></tr><tr><th>2</th><td>4.79308</td><td>4.79308</td></tr><tr><th>3</th><td>1.63038</td><td>1.63038</td></tr><tr><th>4</th><td>5.32593</td><td>5.32593</td></tr><tr><th>5</th><td>3.7549</td><td>3.7549</td></tr><tr><th>6</th><td>2.8901</td><td>2.8901</td></tr><tr><th>7</th><td>3.14794</td><td>3.14794</td></tr><tr><th>8</th><td>3.88091</td><td>3.88091</td></tr><tr><th>9</th><td>1.73055</td><td>1.73055</td></tr><tr><th>10</th><td>3.86106</td><td>3.86106</td></tr></tbody></table></div><p>We also define another <code>Datom</code> type <code>RandDF</code> that returns uniform random numbers in a <code>Dataframe</code>, for later use. The <code>meanv</code> parameter specifies the mean of the uniform random numbers.</p><pre><code class="language-julia">RuleDSL.@datom RandDF begin
    n::Int
    meanv::Float64

    function fwddata!()
        return [DataFrame(v=(rand(n) .- 0.5 .+ meanv))] # create a random vector
    end
end</code></pre><pre><code class="language-none">fwddata! (generic function with 26 methods)</code></pre><h2 id=".-Rules-1"><a class="docs-heading-anchor" href="#.-Rules-1">2. Rules</a><a class="docs-heading-anchor-permalink" href="#.-Rules-1" title="Permalink"></a></h2><p>The <code>Atom</code> and its subtype <code>Datom</code> are generic abstractions for atomic numerical and data processing algorithms. However, just having atoms is not enough to build a working system or application, we still need to connect these atoms in a meaningful way to create a system or application. The RuleDSL is a high level domain specific language (DSL) exactly designed for that purpose. RuleDSL specifiies precisely how atoms should be connected to one another to form a computation DAG (directed acyclic graph) for the entire system or application.</p><p>The RuleDSL is a graph programming language, it has a very limited syntax for creating DAGs. It doesn&#39;t support most constructs in a conventional programming languages, such as variables, functions, branches or inheritance. RuleDSL only contains discreate declaration of rules, therefore it is much easier to learn and use than the full-fledged programming language. The <code>Atom</code> is an interface to traditional programming languages and libraries. The combination of Rules and Atoms are extremely powerful and expressive, they offer the best features from the traditional and graph programming. Together they can create systems of any scale and complexity with a minimal amount of code.</p><h3 id=".1-RuleDSL-Syntax-1"><a class="docs-heading-anchor" href="#.1-RuleDSL-Syntax-1">2.1 RuleDSL Syntax</a><a class="docs-heading-anchor-permalink" href="#.1-RuleDSL-Syntax-1" title="Permalink"></a></h3><p>We use Fibonacci sequence as an example to describe the RuleDSL syntax. The following is a Fibonacci like sequence using the <code>WSumDF</code> datom we just defined. This example is different from the classic Fibonacci sequence in that its two initial terms are random vectors intead of scalar 0 and 1; thus the recursive summation is applied to random vectors instead of scalars.</p><pre><code class="language-julia">RuleDSL.@addrules seq begin
    fib(n::Int) = RuleDSL.Alias(fib(n, Val(n &lt;= 1))) # binds the 2nd parameter for convenience, Alias is an atom that passes the outputs of other rules

    fib(f::Float64) = RuleDSL.Alias(fib(Int(floor(f)))) # adapting rule for a floating point parameter

    fib(n::Int, isend::Val{false}) = begin # defines the recursion of Fibonacci sequence
        WSumDF[[1.0, 1.0]](fib(n - 1, Val(n &lt;= 2)), fib(n - 2, Val(n &lt;= 3)))
    end

    fib(n::Int, isend::Val{true}) = RandDF[10, Float64(n)]() # using the RandDF atom defined earlier, random vector of length 10.
end</code></pre><p>The <code>RuleDSL.@addrules</code> is a macro provided by Julius Graph Engine for writing rules using the Rules DSL. The first argument <code>seq</code> is a user defined namespace to help organize related rules, followed by a list of discrete rules between the <code>begin</code> and <code>end</code>. There are four rules defined in the above declarations, the basic syntax of individual rules are:</p><pre><code class="language-julia">rulename(arg1::Type1, arg2::Type2, ...) = AtomName[a1, a2, a3...](deprule1(args1...), deprule2(args2...), ...)</code></pre><p>For example, in the rule:</p><pre><code class="language-julia">fib(n::Int, isend::Val{false}) = WSumDF[[1.0, 1.0]](fib(n - 1, Val(n &lt;= 2)), fib(n - 2, Val(n &lt;= 3)))</code></pre><ul><li><code>fib</code> is the rule name, the full name of a rule includes its namespace, in this case it   is <code>seq.fib</code></li><li><code>n</code> and <code>isend</code> are two parameters to this rule, with type <code>Int, Val{false}</code>, all rule parameter must have corresponding types in the rule declarations. The <code>Val{false}</code> is a Julia templatized type that enables value based pattern matching (matching the value <code>false</code> in this case).</li><li><code>WSumDF</code> is the atom name, which was defined earlier, the outer square bracket encloses the parameter to the atom&#39;s constructor</li><li><code>[1.; 1.]</code> in the square bracket is the parameter to the Datom <code>WSumDF</code>&#39;s constructor, i.e., it is the weights parameter. The <code>WSumDF[[1.; 1.]]</code> in the rule declaration is directly translated to a call of<code>WSumDF([1.; 1.])</code> to create the <code>WSumDF</code> object at run time.</li><li>the <code>fib(n-1, Val(n&lt;=2)), fib(n-2, Val(n&lt;=3))</code> inside the parenthesis is a list of dependent rules, they must map to existing rules, so that the Graph Engine can recursively expand the rules at run time to create a complete computational graph. A rule can refer to other rules (including itself) as dependencies. In this case, it defines the recursive sum of Fibonacci sequence.</li></ul><p>Besides the Datom <code>WSumDF</code> we have just defined, these <code>seq</code> rules also uses the Atoms defined in the <code>GraphEngine.RuleDSL</code> package, such as <code>RuleDSL.Alias</code>. Julius Graph Engine comes with a rich set of pre-built Atoms that can be used by referring to their fully qualified Atom names. The atom <code>RuleDSL.Alias</code> is a special atom that simply pass the results of the dependent rules, it creates an additional name to improve readability. Alias atom is often used to bind certain rule parameters to concrete values, as shown in the first <code>seq.fib</code> rule above.</p><h3 id=".2-Polymorphism-and-Rule-Matching-1"><a class="docs-heading-anchor" href="#.2-Polymorphism-and-Rule-Matching-1">2.2 Polymorphism and Rule Matching</a><a class="docs-heading-anchor-permalink" href="#.2-Polymorphism-and-Rule-Matching-1" title="Permalink"></a></h3><p>Rules DSL supports multiple dispatch with type and value based polymorphism, as a result it can capture complex data or analytical logic. Multiple rules can have the same rule name with different argument types, for example we have four rules of <code>seq.fib</code> with different parameters above. At run time, the rule with the most precise match by type are invoked, this process continues recursively through rule dependencies until all the dependent rules are resolved. The final result of this rule matching and expansion process is a fully constructed computation graph (a DAG), which is ready to be executed.</p><p>The value based polymorphism is supported using Julia&#39;s templatized type, such as <code>Val{true}</code> or <code>Val{false}</code>. For example, in the first <code>seq.fib</code> rule above, if <code>n &lt;= 1</code>, the isend parameter of the dependent rules become an instance of the type <code>Val{true}</code>, which would match to the last <code>seq.fib</code> rule governing the initial terms.</p><p>To fully understand this process, let&#39;s go through the creation of computational graph for <code>seq.fib(3.2)</code> step by step.</p><pre><code class="language-julia"># override label display on the node to show additional rule parameters
import GraphEngine.RuleDSL: nodelabel
function nodelabel(::AbstractGraphState, ref::NodeRef)
    hdr = &quot;$(ref.ns).$(ref.name)&quot;
    ps = join(simplerepr.(ref.params), &quot;, &quot;)

    return &quot;$hdr($ps)&quot;
end

# create a concrete instance to a rule
ref = RuleDSL.@ref seq.fib(3.2)

# configuration object to pass common parameters to run time
config = RuleDSL.Config()

# run the computation according to the defined rules to create output in the Set
gs = GraphVM.createlocalgraph(config, RuleDSL.GenericData());
GraphVM.calcfwd!(gs, Set([ref]));

svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true, key=&quot;fib&quot;);
GraphIO.postsvg(svg, &quot;quickstart_1.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/depgraph.html?dataurl=127.0.0.1:7395_fib
</code></pre><p align = "center">
<img src="../assets/quickstart_1.svg" alt="" title="Fib"/>
</p>
<p align = "center">
Figure 1 - Fibonacci
</p><p>In the above example, the steps to create the entire computation DAG includes:</p><ol><li>The best matching rule for <code>seq.fib(3.2)</code> is <code>fib(f::Float64)=RuleDSL.Alias(fib(Int(floor(f))))</code>, which is aliased to <code>seq.fib(3)</code> because the parameter <code>Int(floor(f))</code> in the depedent rule evaluates to 3.</li><li>The best matching rule for <code>seq.fib(3)</code> is <code>fib(n::Int)=RuleDSL.Alias(fib(n, Val{n&lt;=1}()))</code>, whose dependent rule is <code>seq.fib(3, Val{false}())</code> where <code>Val(false)</code> is an instance of templatized type <code>Val{false}</code>.</li><li>The best matching rule for <code>seq.fib(3, Val(false))</code> is  <code>fib(n::Int, isend::Val{false})=WSumDF[[1.; 1.]](fib(n-1, Val(n&lt;=2)), fib(n-2, Val(n&lt;=3)))</code>, with 2 dependent rules: <code>seq.fib(2, Val(false))</code> and <code>seq.fib(1, Val(true))</code> .</li><li>The best matching rule for <code>seq.fib(2, Val(false))</code> is again  <code>fib(n::Int, isend::Val{false})=WSumDF[[1.; 1.]](fib(n-1, Val(n&lt;=2)), fib(n-2, Val(n&lt;=3))</code>, with two dependent rules <code>seq.fib(1, Val(true))</code>  and <code>seq.fib(0, Val(true))</code></li><li>The best matching rule for <code>seq.fib(1, Val(true))</code> and <code>seq.fib(0, Val(true))</code> is <code>fib(n::Int, isend::Val{true})=RandDF[10, Float64(n)]()</code>, which is the initial term of the Fibonacci sequence that does not have any further dependencies. Now the graph expansion/creation is complete.</li></ol><p>The above cell&#39;s output contains a url to a web UI, where a user can visualize the entire calculation with all the intemediate results.</p><p>All the data are cached in the gs object, which is of type <code>GraphVM.GraphState</code> and contains all the run time state of the DAG. Data can be retrieved using the <code>getdata</code> method, which takes the hash value of the <code>RuleDSL.NodeRef</code> object. The hash value of RuleDSL.NodeRef object is often used as a unique ID of the node. The relationship between rules, NodeRef, and unique id is the following:</p><p>Rule declaration $ \xrightarrow{\text{bind rule parameters by RuleDSL.@ref}} $ <code>RuleDSL.NodeRef</code> $ \xrightarrow{\text{hash}} $ Unique Node ID</p><p>The <code>RuleDSL.@ref</code> is a convenient macro to create <code>RuleDSL.NodeRef</code> object, which represents fully parameterized rules. For example the following cells shows two <code>RuleDSL.NodeRef</code> objects can be created from the same rule but with different arguments thus having different hash IDs. Both of their values can be retrieved by <code>getdata</code>.</p><pre><code class="language-julia">fib2 = RuleDSL.@ref seq.fib(2, Val{false}())
fib3 = RuleDSL.@ref seq.fib(3, Val{false}())

println(typeof(fib2) =&gt; hash(fib2))
println(typeof(fib3) =&gt; hash(fib3))

v2 = RuleDSL.getdata(gs, hash(fib2))
v3 = RuleDSL.getdata(gs, hash(fib3))

hcat(v2..., v3...; makeunique=true)</code></pre><div class="data-frame"><p>10 rows × 2 columns</p><table class="data-frame"><thead><tr><th></th><th>v</th><th>v_1</th></tr><tr><th></th><th title="Float64">Float64</th><th title="Float64">Float64</th></tr></thead><tbody><tr><th>1</th><td>1.48114</td><td>2.86338</td></tr><tr><th>2</th><td>0.644999</td><td>1.43452</td></tr><tr><th>3</th><td>0.641956</td><td>1.53167</td></tr><tr><th>4</th><td>0.177277</td><td>0.707257</td></tr><tr><th>5</th><td>0.805863</td><td>2.0429</td></tr><tr><th>6</th><td>1.06729</td><td>2.31523</td></tr><tr><th>7</th><td>1.26496</td><td>2.55425</td></tr><tr><th>8</th><td>1.55134</td><td>3.00357</td></tr><tr><th>9</th><td>0.646029</td><td>1.44967</td></tr><tr><th>10</th><td>1.59886</td><td>2.70192</td></tr></tbody></table></div><h3 id=".3-Dynamic-Dependency-1"><a class="docs-heading-anchor" href="#.3-Dynamic-Dependency-1">2.3 Dynamic Dependency</a><a class="docs-heading-anchor-permalink" href="#.3-Dynamic-Dependency-1" title="Permalink"></a></h3><p>A rule&#39;s dependency can by dynamic, i.e., the number and type of dependencies can be different according to the rule&#39;s parameters. For example the following cell defines a sum of all the even number of terms in the Fibonacci sequence:</p><pre><code class="language-julia">RuleDSL.@addrules seq begin
    sumeven(n::Int) = begin
        WSumDF[fill(1.0, length(0:2:n))](RuleDSL.@ref(fib(i) for i in 0:2:n)...)
    end
end</code></pre><p>As shown below, the <code>RuleDSL.@ref(fib(i) for i in 0:2:n)</code> create a vector of RuleDSL.NodeRef object from the list comprehension inside. The <code>...</code> is a special syntax in rule dependency that signals dynamic rule dependencies, it can follow any valid Julia expression or functions that returns an instance or a vector of RuleDSL.NodeRef.</p><pre><code class="language-julia">RuleDSL.@ref seq.fib(5)</code></pre><pre><code class="language-none">seq:fib/5</code></pre><pre><code class="language-julia">RuleDSL.@ref(seq.fib(i) for i in 0:2:5)</code></pre><pre><code class="language-none">3-element Vector{GraphEngine.RuleDSL.NodeRef}:
 seq:fib/0
 seq:fib/2
 seq:fib/4</code></pre><p>The results of the dynamic dependency is shown below.</p><pre><code class="language-julia"># create a concrete instance to a rule
sumeven = RuleDSL.@ref seq.sumeven(5)

# run the computation according to the defined rules to create the desired output
gs = GraphVM.createlocalgraph(config, RuleDSL.GenericData());
GraphVM.calcfwd!(gs, Set([sumeven])); # we want to compute sumeven

svg = GraphIO.postlocalgraph(gss, gs, port, true; key=&quot;even&quot;);
GraphIO.postsvg(svg, &quot;quickstart_2.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/depgraph.html?dataurl=127.0.0.1:7395_even
</code></pre><p align = "center">
<img src="../assets/quickstart_2.svg" alt="" title="Dynamic Dependency"/>
</p>
<p align = "center">
Figure 2 - Dynamic Dependency
</p><h3 id=".4-Multi-line-Rule-1"><a class="docs-heading-anchor" href="#.4-Multi-line-Rule-1">2.4 Multi-line Rule</a><a class="docs-heading-anchor-permalink" href="#.4-Multi-line-Rule-1" title="Permalink"></a></h3><p>So far, all rules we have shown are single line declarations. Sometimes it is convenient to run simple calculations when declaring the rule. To allow multi-line declarations we can wrap up them within <code>begin ... end</code> , as it is shown in the following example of an equivalent declaration of rule <code>seq.sumeven(n::Int)</code>. The rule can be easier to read by using the local variables <code>dep, ws</code>:</p><pre><code class="language-julia">RuleDSL.@addrules seq begin
    sumeven2(n::Int) = begin
        deps = RuleDSL.@ref(fib(i) for i in 0:2:n)
        ws = fill(1.0, length(deps))
        WSumDF[ws](deps...)
    end
end</code></pre><h2 id=".-Runtime-and-GraphData-1"><a class="docs-heading-anchor" href="#.-Runtime-and-GraphData-1">3. Runtime and GraphData</a><a class="docs-heading-anchor-permalink" href="#.-Runtime-and-GraphData-1" title="Permalink"></a></h2><p>The combination of Rules and Atoms are very powerful and expressive, they can build any data and analytical pipeline as a directed acyclic graph (DAG) regardless of its complexity, usually with very few lines of code in RuleDSL. However, a system needs additional run time configurations to function properly, even after the business logic fully specified. Runtime configuration is an important aspect of a running system, which is the topic of this section.</p><p>Runtime configuration usually include the following attributes:</p><ul><li>Distribution: whether a system is running on a local computer or a distributed computing environment</li><li>Caching: should the intermediate results being cached, and how/where it is cached</li><li>Adjoint Algorithmic Differentiation (AAD): whether the system execution includes AAD</li><li>Batch or Streaming: whether the system running once in a batch mode, or running in a live mode with endless streaming data</li></ul><p>In a traditional development environment, separate and duplicated codebases are created in order to support different runtimes. For example, it is common in a bank to have separate and dedicated systems for each combination of (runtime, applications), such as end of day batch system for Macro trading, live intraday system for Equity e-trading, test/UAD environment for XVA, etc. These specialized and dedicated systems do not share much common software, hardware or configuration. As a results, the number of these specialized system can quick multiple and drive up the overall complexity and support cost in a bank, and at the same time hurting its consistency and reliability.</p><p>Julis GraphEngine provides a number of common runtime configurations out of box. Different runtime environment can be created on-demand from a common set of Rules and Atoms defining the business logic. This removes the needs for duplicated implementation of runtime configurations for individual sytems, leading to significant reduction in support cost and system complexity.</p><p>Julius Runtime are implemented as different <code>GraphData</code> types. Each <code>GraphData</code> type implements a specific runtime configuration. In the previous sections, we have already seen the <code>GenericData</code> in action, which is a derived type of <code>GraphData</code>. The following table shows some of the most common <code>GraphData</code> configurations in Julius:</p><table><tr><th style="text-align: center">GraphData Type</th><th style="text-align: center">Caching</th><th style="text-align: center">Batch/Stream</th><th style="text-align: center">support AAD</th><th style="text-align: center">supported Atom type</th></tr><tr><td style="text-align: center"><code>RuleDSL.GenericData</code></td><td style="text-align: center">yes</td><td style="text-align: center">batch</td><td style="text-align: center">no</td><td style="text-align: center">any</td></tr><tr><td style="text-align: center"><code>RuleDSL.NumericalData</code></td><td style="text-align: center">yes</td><td style="text-align: center">batch</td><td style="text-align: center">yes</td><td style="text-align: center"><code>Quantom</code> only</td></tr><tr><td style="text-align: center"><code>RuleDSL.StreamData</code></td><td style="text-align: center">no</td><td style="text-align: center">stream</td><td style="text-align: center">no</td><td style="text-align: center">any</td></tr></table><p>Any <code>GraphData</code> can be used in either local or distributed mode, we only work with local runtime in this notebook, but subsequent tutorials will show the distributed setup. The <code>NumericalData</code> is a <code>GraphData</code> specialized for numerical computation with AAD, which we will cover in another tutorial.</p><p>Next, we will show how streaming use cases can be easily created using the <code>StreamData</code>.</p><h3 id=".1-Streaming-1"><a class="docs-heading-anchor" href="#.1-Streaming-1">3.1 Streaming</a><a class="docs-heading-anchor-permalink" href="#.1-Streaming-1" title="Permalink"></a></h3><p>Streaming is a common runtime use case, e.g., for live intraday pricing and risk during market open. With the <code>RuleDSL.StreamData</code> runtime, Julius can turn any batch system to a streaming system with few lines of code change.</p><p>In the following few cells, we take the Fibnacci sequence as defined above, which operates in the batch mode, and turn it into a streaming processing. Its initial inputs, the <code>fib(0)</code>  and <code>fib(1)</code> terms becomes the streaming input of random vectors.</p><p>To show the effects of streaming, we create a new Datom that averages all the streamed input values.</p><pre><code class="language-julia"># computes the running average of all the value being streamed
RuleDSL.@datom StreamAverage begin
    sum::DataFrame = DataFrame()
    cnt::Vector = [0]

    function fwddata!(x::DataFrame)
        if cnt[1] == 0
            append!(sum, x)
        else
            sum .+= x
        end

        cnt[1] += 1
        [ sum ./ cnt[1] ]
    end
end</code></pre><pre><code class="language-none">fwddata! (generic function with 27 methods)</code></pre><p>Then we define a generic rule for computing stream average from any node. One of the most powerful feature of Julius Rules DSL, is the high order rule, which is a rule declaration that takes a <code>RuleDSL.NodeRef</code> object as parameter.  A high order rule can declare a generic pattern that is applicable to any other node in a graph, for example map/reduce or Monte carlo simulation can be expressed as generic high order rules. We will cover high order rules in more detail in a following map/reduce tutorial.</p><p>In the following high order rule for stream average, the <code>...</code> operator in the dependency indicates dynamic dependency, which is just the input node as defined by the <code>NodeRef</code> parameter. The <code>seq.streamaverage</code> is therefore a generic operation that can be applied to any other node as represented in its argument <code>ref</code>, and it has a single dependency to the node specified by the ref.</p><pre><code class="language-julia">RuleDSL.@addrules seq begin
    streamaverage(ref::RuleDSL.NodeRef) = StreamAverage(ref...)
end

# sources of streaming inputs
srcs = [
    RuleDSL.@ref(seq.fib(0, Val{true}())), RuleDSL.@ref(seq.fib(1, Val{true}()))
]
sd = RuleDSL.StreamData(Set(hash.(srcs)), 1) # create StreamData with queue buffer length of 1

ref = RuleDSL.@ref seq.fib(5)
savg = RuleDSL.@ref seq.streamaverage(ref)

gs2 = GraphVM.createlocalgraph(config, sd) # create a graph using StreamData
GraphVM.calcfwd!(gs2, Set{NodeRef}(savg)); # set up the pipeline of streaming</code></pre><p>The calcfwd! call above builts the pipeline between nodes for streaming. The connection between nodes in StreamData are message queues, where each node runs asynchronously to process the message from the input queue, and then puts the results into the output queue.</p><p>The following cell streams 20,000 different initial inputs, which are randomly drawn by the datom <code>RandDF</code>. Since the final output&#39;s atom is StreamAverage, which computes the running average of all the streamed data, the net result is essentially to compute the Fibonnaci sequence using a Monte Carlo simulation of 20,000 paths, and the results are all close to 5, which is the correct value of the 5th term of the classic Fibonacci sequence.</p><p>Unlike the mini-batch streaming processing in Spark, the streaming implementation in Julius is fully pipelined, where different nodes are processing different streaming inputs concurrently at any given time. As a result, Julius streaming is extremely fast, achieving more than 10,000 messages per seconds.</p><pre><code class="language-julia">@time RuleDSL.pushpullcalc!(gs2, 10000) # stream 10,000 messages, this call can be made multiple times to stream more data
@time RuleDSL.pushpullcalc!(gs2, 10000)
avg = RuleDSL.getdata(gs2, hash(savg))[1] # [1] is because the output is a vector of 1</code></pre><div class="data-frame"><p>10 rows × 1 columns</p><table class="data-frame"><thead><tr><th></th><th>v</th></tr><tr><th></th><th title="Float64">Float64</th></tr></thead><tbody><tr><th>1</th><td>5.0077</td></tr><tr><th>2</th><td>5.03759</td></tr><tr><th>3</th><td>4.99845</td></tr><tr><th>4</th><td>5.01319</td></tr><tr><th>5</th><td>4.97793</td></tr><tr><th>6</th><td>5.00819</td></tr><tr><th>7</th><td>5.00818</td></tr><tr><th>8</th><td>5.01002</td></tr><tr><th>9</th><td>5.01341</td></tr><tr><th>10</th><td>4.99645</td></tr></tbody></table></div><p>Once we are done with streaming, we can tear down the streaming pipeline by calling <code>stopstream!</code> on <code>StreamData</code> to reclaim the resources. Once <code>stopstream!</code> is called, it will no longer accept any more streaming data.</p><pre><code class="language-julia">RuleDSL.stopstream!(sd);</code></pre><pre><code class="language-julia">GraphVM.servedata(gss, gs2, port; key=&quot;stream&quot;);</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/depgraph.html?dataurl=127.0.0.1:7395_stream
</code></pre><p>revert back nodelabel to default definition</p><pre><code class="language-julia">nodelabel(gs::RuleDSL.AbstractGraphState, ref::RuleDSL.NodeRef)=haskey(ref.meta, :label) ? ref.meta[:label] : &quot;$(ref.ns).$(ref.name)&quot;</code></pre><pre><code class="language-none">nodelabel (generic function with 4 methods)</code></pre><h2 id=".-Exercise-1"><a class="docs-heading-anchor" href="#.-Exercise-1">4. Exercise</a><a class="docs-heading-anchor-permalink" href="#.-Exercise-1" title="Permalink"></a></h2><p>Thanks for your attention! Now you have learnt the basics of <strong>Julius Graph Engine</strong>, it is time to get your hands dirty and write your own rules and atoms! Here is an suggested exercise:</p><p>Modify the streaming use case above, to also report the calculation of Monte Carlo error, which is the standard deviation of the samples divided by the square root of the number of samples. You can take advantage of the following relationship <span>$\sigma^2(x)=E[x^2] - E^2[x]$</span> by tracking the average of squares. Then the MC error is <span>$\frac{\sigma(x)}{\sqrt{n}}$</span> where <span>$n$</span> is the number of samples streamed.</p><p>There can be different approaches for doing this:</p><ol><li>create a new Datom and corresponding rule, similar to <code>StreamAverage</code> and <code>seq.streamaverage</code>, that computes the running mean and MC error, and return them as two DataFrames in the output vector, or two columns in the same DataFrrame.</li><li>create new Datoms for arithmetic operations like Square, Subtraction and Sqrt on type DataFrame, then compute the MC error by writing new rules that connects these new datoms</li></ol><p>The first approach is quick and fast, while the second approach is more generic and reusable, with additional benefits of being able to see the intermediate results.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../index.html">« Introduction</a><a class="docs-footer-nextpage" href="t002_titanic.html">2 Machine Learning »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 31 March 2022 13:28">Thursday 31 March 2022</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
