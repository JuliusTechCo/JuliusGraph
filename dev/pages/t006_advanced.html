<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>6 Advanced Features · Julius GraphEngine Tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Julius GraphEngine Tutorials</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="t001_quickstart.html">1 Quick Start</a></li><li><a class="tocitem" href="t002_machinelearning.html">2 Machine Learning</a></li><li><a class="tocitem" href="t003_mapreduce.html">3 MapReduce</a></li><li><a class="tocitem" href="t004_distributedml.html">4 Distributed Machine Learning</a></li><li><a class="tocitem" href="t005_aad.html">5 Adjoint Algorithmic Differentiation (AAD)</a></li><li class="is-active"><a class="tocitem" href="t006_advanced.html">6 Advanced Features</a><ul class="internal"><li><a class="tocitem" href="#How-to-use-this-tutorial-1"><span>How to use this tutorial</span></a></li><li><a class="tocitem" href="#Introduction-1"><span>Introduction</span></a></li><li><a class="tocitem" href="#Caching-1"><span>Caching</span></a></li><li><a class="tocitem" href="#Namespace-Clone-and-Override-1"><span>Namespace Clone and Override</span></a></li><li><a class="tocitem" href="#Packaging-1"><span>Packaging</span></a></li><li><a class="tocitem" href="#Error-Handling-1"><span>Error Handling</span></a></li><li><a class="tocitem" href="#Manage-Rules-Upgrades-1"><span>Manage Rules Upgrades</span></a></li></ul></li><li><a class="tocitem" href="t007_persist.html">7 ML Experiment Tracking and Persisting</a></li><li><a class="tocitem" href="t008_benchmark.html">8 Graph Creation Benchmark</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="t006_advanced.html">6 Advanced Features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="t006_advanced.html">6 Advanced Features</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliusTechCo/Tutorials/blob/main/src/advanced.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-6:-Advanced-Features-1"><a class="docs-heading-anchor" href="#Tutorial-6:-Advanced-Features-1">Tutorial 6: Advanced Features</a><a class="docs-heading-anchor-permalink" href="#Tutorial-6:-Advanced-Features-1" title="Permalink"></a></h1><h2 id="How-to-use-this-tutorial-1"><a class="docs-heading-anchor" href="#How-to-use-this-tutorial-1">How to use this tutorial</a><a class="docs-heading-anchor-permalink" href="#How-to-use-this-tutorial-1" title="Permalink"></a></h2><ul><li>This tutorial is also available in Jupyter notebook format. To access and run the Jupyter notebook version of the tutorial, please sign up for free developer access at <a href="https://juliusgraph.com/user/signup">https://juliusgraph.com/user/signup</a>, then go to Julius&#39; developer environment at <a href="https://juliusgraph.com">https://juliusgraph.com</a>.</li><li>Additional resources (video demos &amp; blogs) are available at <a href="http://juliustech.co">http://juliustech.co</a>.</li><li>To report bugs or request new features, please raise an issue <a href="https://github.com/JuliusTechCo/JuliusGraph/issues">here</a>. To schedule a live demo, please go to <a href="http://juliustech.co">http://juliustech.co</a>. Please email us at info@juliustech.co for other general inquiries.</li></ul><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p>This tutorial covers some advanced features in the Julius Graph Engine:</p><ul><li>Caching</li><li>Cloning of namespaces and Change management</li><li>Packaging rules into an atom</li><li>Error Handling</li></ul><p>We use the same Fibonacci sequence example as in the AAD tutorial to illustrate these advanced topics.</p><pre><code class="language-julia"># disable the display of information logging
using Base.CoreLogging
disable_logging(CoreLogging.Info)

using GraphEngine: RuleDSL, GraphVM
using GraphEngine.RuleDSL
using GraphIO

# start data server for web UI
gss = Dict{String,RuleDSL.AbstractGraphState}()
port = GraphVM.drawdataport()
@async GraphVM.startresponder(gss, port)</code></pre><pre><code class="language-none">Task (runnable) @0x00007f65acfa1e40</code></pre><p>The following few rules define the Fibonacci sequence using the rule syntax.</p><pre><code class="language-julia">@addrules series begin
    fib(x::Float64) = Alias(fib(Int(floor(x))))
    fib(n::Int) = RuleDSL.Alias(fib(n, Val(n &lt;= 1)))
    fib(n::Int, isend::Val{false}) = begin
        RuleDSL.WeightedSum[[1.0; 1.0]](
            fib(n - 1, Val(n &lt;= 2)), fib(n - 2, Val(n &lt;= 3))
        )
    end
    fib(n::Int, isend::Val{true}) = RuleDSL.Constant[[fill(Float64(n), 1)]]()
end

config = RuleDSL.Config();</code></pre><p>The following two functions override the nodelabel function for the customized display of graph nodes. Users can freely override them to customize the text label display on the computation graph.</p><pre><code class="language-julia">import GraphEngine.RuleDSL: nodelabel

# override displays
function nodelabel(::RuleDSL.AbstractGraphState, r::RuleDSL.RuleNode)
    hdr = &quot;$(r.ns).$(r.op[1])&quot;
    typestr(x) = x.args[2]
    typ = join(typestr.(r.op[2]), &quot;, &quot;)

    return hdr * &quot;($typ)&quot;
end

function nodelabel(::RuleDSL.AbstractGraphState, ref::RuleDSL.NodeRef)
    hdr = &quot;$(ref.ns).$(ref.name)&quot;
    ps = join(simplerepr.(ref.params), &quot;, &quot;)

    return &quot;$hdr($ps)&quot;
end</code></pre><pre><code class="language-none">nodelabel (generic function with 4 methods)</code></pre><p>We first compute the primal and AAD of a Fibonacci sequence.</p><pre><code class="language-julia">fib5 = @ref series.fib(5.2)
fib0 = @ref series.fib(0, Val(true))
fib1 = @ref series.fib(1, Val(true))

cs = RuleDSL.NumericalData(config, Set([fib0, fib1]));
gs = RuleDSL.createlocalgraph(config, cs);
RuleDSL.calcfwd!(gs, Set([fib5]));
RuleDSL.calcback!(gs, Set([hash(fib5)]));</code></pre><p>We can retrieve the results of <span>$\vec y$</span> and the 1st order derivatives from AAD.</p><pre><code class="language-julia">y = RuleDSL.getys(gs, hash(fib5))
dydx0 = RuleDSL.getyds(gs, hash(fib0), hash(fib5))
dydx1 = RuleDSL.getyds(gs, hash(fib1), hash(fib5))

println(&quot;fib5 =&quot;, y[1])
println(&quot;dfib5_dfib0 =&quot;, dydx0[1])
println(&quot;dfib5_dfib1 =&quot;, dydx1[1])</code></pre><pre><code class="language-none">fib5 =[5.0]
dfib5_dfib0 =[3.0]
dfib5_dfib1 =[5.0]
</code></pre><p>The corresponding computational graph is shown here, and you can click the link below to see it in an interactive web UI.</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;fib5&quot;);
GraphIO.postsvg(svg, &quot;adv_1.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/ui/depgraph.html?dataurl=127.0.0.1:7753_fib5
</code></pre><p align = "center">
<img src="../assets/adv_1.svg" alt="" title="Fib 5"/>
</p>
<p align = "center">
Figure 1 - Fibonacci with AAD
</p><h2 id="Caching-1"><a class="docs-heading-anchor" href="#Caching-1">Caching</a><a class="docs-heading-anchor-permalink" href="#Caching-1" title="Permalink"></a></h2><p>Because Julius automatically caches all the intermediate results in the graph, any incremental computation will re-use existing values in the cache, instead of recomputing them from scratch. The following cells show that when computing <code>fib(10)</code>, all the nodes up to <code>fib(5)</code> from the previous step are re-used.</p><pre><code class="language-julia">fib10 = @ref series.fib(10)
GraphVM.calcfwd!(gs, Set([fib10]));
RuleDSL.calcback!(gs, Set([hash(fib10)]));

y = RuleDSL.getys(gs, hash(fib10))
df10df0 = RuleDSL.getyds(gs, hash(fib0), hash(fib10))
df10df1 = RuleDSL.getyds(gs, hash(fib1), hash(fib10))

println(&quot;fib10 =&quot;, y[1])
println(&quot;dfib10_dfib0 =&quot;, df10df0[1])
println(&quot;dfib10_dfib1 =&quot;, df10df1[1])</code></pre><pre><code class="language-none">fib10 =[55.0]
dfib10_dfib0 =[34.0]
dfib10_dfib1 =[55.0]
</code></pre><p>The corresponding computational graph is shown below:</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;fib10&quot;);
GraphIO.postsvg(svg, &quot;adv_2.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/ui/depgraph.html?dataurl=127.0.0.1:7753_fib10
</code></pre><p align = "center">
<img src="../assets/adv_2.svg" alt="" title="Fib 10"/>
</p>
<p align = "center">
Figure 2 - Caching
</p><h2 id="Namespace-Clone-and-Override-1"><a class="docs-heading-anchor" href="#Namespace-Clone-and-Override-1">Namespace Clone and Override</a><a class="docs-heading-anchor-permalink" href="#Namespace-Clone-and-Override-1" title="Permalink"></a></h2><p>Rules are organized within individual namespaces in the Julius RuleDSL. For example the <code>series</code> is a namespace in the rules declaration above. One important feature of Julius is that the rules can be cloned to different namespaces and overridden. This facilitates comparisons between the old and new versions of rules, making change management and impact analysis very simple in practice.</p><p>For example, if we update the above Fibonacci sequence definition to take random vectors as fib(0) and fib(1) instead of 0 and 1, we can create a clone of the namespace &quot;series&quot; and override the corresponding rules.</p><pre><code class="language-julia">@clone series =&gt; vecs

@addrules vecs begin
    fib(n::Int, isend::Val{true}) = RuleDSL.Constant[[randn(10)]]()
end</code></pre><pre><code class="language-julia">vfib10 = @ref vecs.fib(10)
@time GraphVM.calcfwd!(gs, Set([vfib10]));

y = RuleDSL.getys(gs, hash(vfib10))
println(&quot;vfib10 =&quot;, y[1])</code></pre><pre><code class="language-none">  0.313649 seconds (358.82 k allocations: 20.062 MiB, 99.50% compilation time)
vfib10 =[40.50939848981055, 20.3372041492605, 15.732516368026499, -113.42522218551576, -11.644251624786978, 13.735208123314047, -101.81941691527474, -27.10690904794512, 17.83110502504627, -9.877230151986542]
</code></pre><p>We can show a side by side comparison of the two versions of the calculation, before and after changing the initial values to random vectors. You can compare the before and after values of individual nodes in the interactive web UI, by clicking the URL below.</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;vecs&quot;);
GraphIO.postsvg(svg, &quot;adv_3.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/ui/depgraph.html?dataurl=127.0.0.1:7753_vecs
</code></pre><p align = "center">
<img src="../assets/adv_3.svg" alt="" title="Comparisons"/>
</p>
<p align = "center">
Figure 3 - Override & Compare
</p><h2 id="Packaging-1"><a class="docs-heading-anchor" href="#Packaging-1">Packaging</a><a class="docs-heading-anchor-permalink" href="#Packaging-1" title="Permalink"></a></h2><p>When the computational graph becomes sufficiently large, it can be difficult for a user to navigate and visualize. Julius supports packaged atoms, which uses a set of Rules to define an atom with its own internal computational graph. The packaged atom can then be subsequently referred to by other rules. The iterative layering of rules and packaged atoms allows easy composition of complicated logic and analytics.</p><p>The following code cell shows how to create and use a packaged atom, using the macro <code>RuleDSL.@combonquantom</code>. A similar <code>RuleDSL.@combodatom</code> is also provided to create packaged <code>Datom</code> object.</p><pre><code class="language-julia">using GraphEngine.RuleDSL: Source

# the first argument must be the config
@comboquantom function Fib[config::RuleDSL.Config, m::Int](fac.xarg(0), fac.xarg(1))
    fib(n::Int) = Alias(fib(n, Val(n &lt;= 1)))
    fib(n::Int, isend::Val{false}) = begin
        RuleDSL.WeightedSum[[1.0; 1.0]](fib(n - 1, Val(n &lt;= 2)), fib(n - 2, Val(n &lt;= 3)))
    end
    fib(n::Int, isend::Val{true}) = Alias(fac.xarg(n))

    return fib(m)
end

@addrules pack begin
    randv(id::Int, d::Int) = RuleDSL.Constant[[randn(d)]]()
    fib(n::Int, d::Int) = Fib[@config, n](randv(0, d), randv(1, d))
end</code></pre><pre><code class="language-julia">d = 10
p20 = @ref pack.fib(20, d)
p0 = @ref pack.randv(0, d)
p1 = @ref pack.randv(1, d)

gs = RuleDSL.createlocalgraph(config, RuleDSL.NumericalData())
RuleDSL.calcfwd!(gs, Set([p20]));
RuleDSL.calcback!(gs, Set(hash.(p20)), Set([p0; p1]));

dp20dp0 = RuleDSL.getyds(gs, hash(p0), hash(p20))
dp10dp1 = RuleDSL.getyds(gs, hash(p1), hash(p20))

println(&quot;fib20 =&quot;, RuleDSL.getys(gs, hash(p20)))
println(&quot;dfib20_dfib0 =&quot;, dp20dp0[1])
println(&quot;dfib20_dfib1 =&quot;, dp20dp0[1])</code></pre><pre><code class="language-none">fib20 =[[-4124.536049582304, -968.1550041387593, 4944.059377340111, 7844.940820910798, -8196.13595291703, -9139.367481949244, -10156.215233288294, 2365.19847264999, 8946.062644479065, 3138.3764059774153]]
dfib20_dfib0 =[4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0]
dfib20_dfib1 =[4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0]
</code></pre><p>The AAD works automatically across the packaged atoms, as shown in the cell above. The following cell shows that the top level graph is much simpler to visualize using the packaged atom. A user can drill down to the full details of the inner graph of the packaged atom from the interactive web UI by clicking on the URL below.</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;pack&quot;);
GraphIO.postsvg(svg, &quot;adv_4.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/ui/depgraph.html?dataurl=127.0.0.1:7753_pack
</code></pre><p align = "center">
<img src="../assets/adv_4.svg" alt="" title="Packaged Atom"/>
</p>
<p align = "center">
Figure 4 - Packaged Atom
</p><h2 id="Error-Handling-1"><a class="docs-heading-anchor" href="#Error-Handling-1">Error Handling</a><a class="docs-heading-anchor-permalink" href="#Error-Handling-1" title="Permalink"></a></h2><p>The Julius Graph Engine handles errors graciously and gives users clear indications on where the errors arise. The following code creates an exception using the <code>Error</code> Quantom at the back AD stage.</p><pre><code class="language-julia">using Test

@clone series =&gt; err

@addrules err begin
    # parameter 2 in Error create error at ad stage
    fib(n::Int, isend::Val{false}) = RuleDSL.Error[2](series.fib(n, isend))
end

efibn = @ref err.fib(10)
xs = Set([@ref series.fib(0); @ref series.fib(1)])

gs = RuleDSL.createlocalgraph(config, RuleDSL.NumericalData())
try
    RuleDSL.calcfwd!(gs, Set([efibn]))
    RuleDSL.calcback!(gs, Set(hash(efibn)), xs)
catch e
    println(&quot;error caught: $e&quot;)
end</code></pre><pre><code class="language-none">0</code></pre><p>The nodes with errors are highlighted automatically in the interactive web UI under the section &quot;errors in graph&quot;.</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;err&quot;);
GraphIO.postsvg(svg, &quot;adv_5.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/ui/depgraph.html?dataurl=127.0.0.1:7753_err
</code></pre><p align = "center">
<img src="../assets/adv_5.svg" alt="" title="Error Handling"/>
</p>
<p align = "center">
Figure 5 - Error Handling
</p><h2 id="Manage-Rules-Upgrades-1"><a class="docs-heading-anchor" href="#Manage-Rules-Upgrades-1">Manage Rules Upgrades</a><a class="docs-heading-anchor-permalink" href="#Manage-Rules-Upgrades-1" title="Permalink"></a></h2><p>During the development process, we may need to upgrade certain rules to a newer version, while encouraging existing users to migrate. This can be achieved through the use of warning messages. For example, if we want to retire the series.fib and migrate users to the new version of vecs.fib, a warning message can be generated for existing users on the old rules:</p><pre><code class="language-julia">@addrules series begin
    fib(n::Int, isend::Val{true}; warn=&quot;deprecated, please use vecs.fib instead&quot;) = begin
        RuleDSL.Constant[[fill(Float64(n), 1)]]()
    end
end

efibn = @ref series.fib(10)
gs = RuleDSL.createlocalgraph(config, RuleDSL.NumericalData(Set{UInt}()))
@time RuleDSL.calcfwd!(gs, Set([efibn]));</code></pre><pre><code class="language-none">┌ Warning: rule series.fib warning: deprecated, please use vecs.fib instead
└ @ Main.##262 /home/julius/dev/Julius/GraphEngineDev/src/RuleDSL/rulepiler.jl:186
┌ Warning: rule series.fib warning: deprecated, please use vecs.fib instead
└ @ Main.##262 /home/julius/dev/Julius/GraphEngineDev/src/RuleDSL/rulepiler.jl:186
  0.122978 seconds (292.76 k allocations: 16.506 MiB, 98.94% compilation time)
</code></pre><p>After the migration period has ended, we can change the old rules to throw an error and force users to upgrade.</p><pre><code class="language-julia">@addrules series begin
    fib(n::Int, isend::Val{true}; error=&quot;deprecated, please use vecs.fib instead&quot;) = begin
        RuleDSL.Constant[[fill(Float64(n), 1)]]()
    end
end

gs = RuleDSL.createlocalgraph(config, RuleDSL.NumericalData())
try
    RuleDSL.calcfwd!(gs, Set([efibn]))
catch e
    println(&quot;error caught $e&quot;)
end</code></pre><pre><code class="language-none">error caught rule series.fib: deprecated, please use vecs.fib instead
</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="t005_aad.html">« 5 Adjoint Algorithmic Differentiation (AAD)</a><a class="docs-footer-nextpage" href="t007_persist.html">7 ML Experiment Tracking and Persisting »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 12 April 2022 23:27">Tuesday 12 April 2022</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
