<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>6 Advanced Features · Julius GraphEngine Tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Julius GraphEngine Tutorials</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="t001_quickstart.html">1 Quick Start</a></li><li><a class="tocitem" href="t002_titanic.html">2 Machine Learning</a></li><li><a class="tocitem" href="t003_mapreduce.html">3 MapReduce</a></li><li><a class="tocitem" href="t004_bagging.html">4 Distributed Machine Learning Pipeline</a></li><li><a class="tocitem" href="t005_aad.html">5 Adjoint Algorithmic Differentiation (AAD)</a></li><li class="is-active"><a class="tocitem" href="t006_advanced.html">6 Advanced Features</a><ul class="internal"><li><a class="tocitem" href="#How-to-use-this-tutorial-1"><span>How to use this tutorial</span></a></li><li><a class="tocitem" href="#Introduction-1"><span>Introduction</span></a></li><li><a class="tocitem" href="#Caching-1"><span>Caching</span></a></li><li><a class="tocitem" href="#Namespace-Clone-and-Override-1"><span>Namespace Clone and Override</span></a></li><li><a class="tocitem" href="#Packaging-1"><span>Packaging</span></a></li><li><a class="tocitem" href="#Error-Handling-1"><span>Error Handling</span></a></li><li><a class="tocitem" href="#Manage-Rules-Upgrades-1"><span>Manage Rules Upgrades</span></a></li></ul></li><li><a class="tocitem" href="t007_persist.html">7 MLOps: ML Experiment Tracking and Persisting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="t006_advanced.html">6 Advanced Features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="t006_advanced.html">6 Advanced Features</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliusTechCo/Tutorials/blob/main/src/advanced.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-6:-Advanced-Features-1"><a class="docs-heading-anchor" href="#Tutorial-6:-Advanced-Features-1">Tutorial 6: Advanced Features</a><a class="docs-heading-anchor-permalink" href="#Tutorial-6:-Advanced-Features-1" title="Permalink"></a></h1><h2 id="How-to-use-this-tutorial-1"><a class="docs-heading-anchor" href="#How-to-use-this-tutorial-1">How to use this tutorial</a><a class="docs-heading-anchor-permalink" href="#How-to-use-this-tutorial-1" title="Permalink"></a></h2><ul><li>Select &quot;run all cells&quot; on this notebook from the Run menu in Jupyter notebook or Jupyter lab. This step will produce intermediate data output and charts.</li><li>Some cells print out a url, which you can click on and bring up an interactive web UI to visualize the graph data.</li><li>In the unlikely event that the notebook becomes irresponsive, you can try &quot;Restart Kernel&quot; from the Kernel menu, then run individual cells one by one using <code>Shift+Enter</code>.</li><li>Some tutorials use local clusters consisting of multiple processes to mimic the effects of graph distribution over a remote cluster. By default, these local clusters automatically stop after idling for 15 minutes to conserve CPU and memory resources. You will need to rerun the entire notebook if your local cluster stopped due to inactivity.</li><li>Additional resources (video demos &amp; blogs) are available at http://juliustech.co.</li><li>To report any issues, get help or request features, please raise an issue at https://github.com/JuliusTechCo/JuliusGraph/issues.</li></ul><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p>This tutorial covers some advanced features in Julius Graph Engine:</p><ul><li>Caching</li><li>Cloning of namespace and Change management</li><li>Package rules into an atom.</li><li>Error Handling</li></ul><p>We use the same Fibonacci sequence example as in the AAD tutorial to illustrate these advanced topics.</p><pre><code class="language-julia"># disable the display of information logging
using Base.CoreLogging
disable_logging(CoreLogging.Info)

using GraphEngine: RuleDSL, GraphVM
using GraphEngine.RuleDSL
using GraphIO

# start data server for web UI
gss = Dict{String,RuleDSL.AbstractGraphState}()
port = GraphVM.drawdataport()
@async GraphVM.startresponder(gss, port)</code></pre><pre><code class="language-none">Task (runnable) @0x00007f292ff687f0</code></pre><p>The following few rules defines the Fibonacci sequence using the rule syntax.</p><pre><code class="language-julia">@addrules series begin
    fib(x::Float64) = Alias(fib(Int(floor(x))))
    fib(n::Int) = RuleDSL.Alias(fib(n, Val(n &lt;= 1)))
    fib(n::Int, isend::Val{false}) = begin
        RuleDSL.WeightedSum[[1.0; 1.0]](
            fib(n - 1, Val(n &lt;= 2)), fib(n - 2, Val(n &lt;= 3))
        )
    end
    fib(n::Int, isend::Val{true}) = RuleDSL.Constant[[fill(Float64(n), 1)]]()
end

config = RuleDSL.Config();</code></pre><p>The following two functions override the nodelabel function for the customized display of graph nodes. Users can freely override them to customize the text label display of the computation graph.</p><pre><code class="language-julia">import GraphEngine.RuleDSL: nodelabel

# override displays
function nodelabel(::RuleDSL.AbstractGraphState, r::RuleDSL.RuleNode)
    hdr = &quot;$(r.ns).$(r.op[1])&quot;
    typestr(x) = x.args[2]
    typ = join(typestr.(r.op[2]), &quot;, &quot;)

    return hdr * &quot;($typ)&quot;
end

function nodelabel(::RuleDSL.AbstractGraphState, ref::RuleDSL.NodeRef)
    hdr = &quot;$(ref.ns).$(ref.name)&quot;
    ps = join(simplerepr.(ref.params), &quot;, &quot;)

    return &quot;$hdr($ps)&quot;
end</code></pre><pre><code class="language-none">nodelabel (generic function with 4 methods)</code></pre><p>We first compute the primal and AAD of a Fibonacci sequence.</p><pre><code class="language-julia">fib5 = @ref series.fib(5.2)
fib0 = @ref series.fib(0, Val(true))
fib1 = @ref series.fib(1, Val(true))

cs = RuleDSL.NumericalData(config, Set([fib0, fib1]));
gs = RuleDSL.createlocalgraph(config, cs);
RuleDSL.calcfwd!(gs, Set([fib5]));
RuleDSL.calcback!(gs, Set([hash(fib5)]));</code></pre><p>We can retrieve the results of <span>$\vec y$</span> and the 1st order derivatives from AAD.</p><pre><code class="language-julia">y = RuleDSL.getys(gs, hash(fib5))
dydx0 = RuleDSL.getyds(gs, hash(fib0), hash(fib5))
dydx1 = RuleDSL.getyds(gs, hash(fib1), hash(fib5))

println(&quot;fib5 =&quot;, y[1])
println(&quot;dfib5_dfib0 =&quot;, dydx0[1])
println(&quot;dfib5_dfib1 =&quot;, dydx1[1])</code></pre><pre><code class="language-none">fib5 =[5.0]
dfib5_dfib0 =[3.0]
dfib5_dfib1 =[5.0]
</code></pre><p>The corresponding computation graph is shown below, and you can click the link below to see it in an interactive web UI.</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;fib5&quot;);
GraphIO.postsvg(svg, &quot;adv_1.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/depgraph.html?dataurl=127.0.0.1:7140_fib5
</code></pre><p align = "center">
<img src="../assets/adv_1.svg" alt="" title="Fib 5"/>
</p>
<p align = "center">
Figure 1 - Fibonacci with AAD
</p><h2 id="Caching-1"><a class="docs-heading-anchor" href="#Caching-1">Caching</a><a class="docs-heading-anchor-permalink" href="#Caching-1" title="Permalink"></a></h2><p>Julius automatic caching of all intermediate computation results in the graph, any incremental computation will re-use existing values in the cache, instead of being recomputing them from scatch. The following cells shows that when computing <code>fib(10)</code> all the nodes up to <code>fib(5)</code> from previous step is re-used.</p><pre><code class="language-julia">fib10 = @ref series.fib(10)
GraphVM.calcfwd!(gs, Set([fib10]));
RuleDSL.calcback!(gs, Set([hash(fib10)]));

y = RuleDSL.getys(gs, hash(fib10))
df10df0 = RuleDSL.getyds(gs, hash(fib0), hash(fib10))
df10df1 = RuleDSL.getyds(gs, hash(fib1), hash(fib10))

println(&quot;fib10 =&quot;, y[1])
println(&quot;dfib10_dfib0 =&quot;, df10df0[1])
println(&quot;dfib10_dfib1 =&quot;, df10df1[1])</code></pre><pre><code class="language-none">fib10 =[55.0]
dfib10_dfib0 =[34.0]
dfib10_dfib1 =[55.0]
</code></pre><p>The corresponding computation graph is shown below:</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;fib10&quot;);
GraphIO.postsvg(svg, &quot;adv_2.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/depgraph.html?dataurl=127.0.0.1:7140_fib10
</code></pre><p align = "center">
<img src="../assets/adv_2.svg" alt="" title="Fib 10"/>
</p>
<p align = "center">
Figure 2 - Caching
</p><h2 id="Namespace-Clone-and-Override-1"><a class="docs-heading-anchor" href="#Namespace-Clone-and-Override-1">Namespace Clone and Override</a><a class="docs-heading-anchor-permalink" href="#Namespace-Clone-and-Override-1" title="Permalink"></a></h2><p>Rules are organized within individual namespaces in Julius RuleDSL, for example the <code>series</code> is a namespace in the rules declaration above. One important feature of Julius is that the rules can be cloned to different namespace and overridden. This facilitates comparisons between the old and new versions of rules, making change management and impact analysis much easier.</p><p>For example, if we update the above Fibonacci sequence definition to take random vectors as fib(0) and fib(1) instead of 0 and 1, we can create a clone of the namespace &quot;series&quot; and override the corresponding rules.</p><pre><code class="language-julia">@clone series =&gt; vecs

@addrules vecs begin
    fib(n::Int, isend::Val{true}) = RuleDSL.Constant[[randn(10)]]()
end</code></pre><pre><code class="language-julia">vfib10 = @ref vecs.fib(10)
@time GraphVM.calcfwd!(gs, Set([vfib10]));

y = RuleDSL.getys(gs, hash(vfib10))
println(&quot;vfib10 =&quot;, y[1])</code></pre><pre><code class="language-none">  0.349831 seconds (358.83 k allocations: 20.063 MiB, 99.51% compilation time)
vfib10 =[-0.7783191893421139, -117.94264388389712, -31.238338190453632, -102.16013199504734, -125.94628360800748, -85.58616658653082, 88.40834726735042, 5.77002976282221, 59.85026239039285, -5.740059205113482]
</code></pre><p>We can show a side by side comparison of the two versions of the calculation, before and after changing the initial values to random vectors. You can compare the before and afer values of individual node in the interactive web UI, by clicking the URL below.</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;vecs&quot;);
GraphIO.postsvg(svg, &quot;adv_3.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/depgraph.html?dataurl=127.0.0.1:7140_vecs
</code></pre><p align = "center">
<img src="../assets/adv_3.svg" alt="" title="Comparisons"/>
</p>
<p align = "center">
Figure 3 - Override & Compare
</p><p>Julius AAD implementation supoorts multiple sensitivity views from the same primal calculation. A sensitivity view is a Jacobian matrix <span>$\frac{\partial \vec y}{\partial \vec x}$</span> where <span>$\vec y$</span> and <span>$\vec x$</span> can be any dependent node in the graph. For the same primal calculation, different sensitivity views can be computed without repeating the primal calculations.</p><p>The following few cells shows the results of different sensitivity views. Please note that the AAD output of the vectorized version of Fibonacci sequence is a full Jacobian matrix.</p><pre><code class="language-julia">v10 = @ref vecs.fib(10)
v0 = @ref vecs.fib(0, Val(true))
v1 = @ref vecs.fib(1, Val(true))

RuleDSL.calcback!(gs, Set(hash.([v10])), Set([v0; v1]));

dv10_dv0 = RuleDSL.getyds(gs, hash(v0), hash(v10))
dv10_dv1 = RuleDSL.getyds(gs, hash(v1), hash(v10))

println(&quot;fib_v10 = &quot;, RuleDSL.getys(gs, hash(v10))[1])
println(&quot;dv10_dv0 = &quot;, dv10_dv0[1])
println(&quot;dv10_dv1 = &quot;, dv10_dv1[1])</code></pre><pre><code class="language-none">fib_v10 = [-0.7783191893421139, -117.94264388389712, -31.238338190453632, -102.16013199504734, -125.94628360800748, -85.58616658653082, 88.40834726735042, 5.77002976282221, 59.85026239039285, -5.740059205113482]
dv10_dv0 = [34.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 34.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 34.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 34.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 34.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 34.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 34.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 34.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 34.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 34.0]
dv10_dv1 = [55.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 55.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 55.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 55.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 55.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 55.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 55.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 55.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 55.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 55.0]
</code></pre><pre><code class="language-julia">v8 = @ref vecs.fib(8, Val(false))
v2 = @ref vecs.fib(2, Val(false))
v3 = @ref vecs.fib(3, Val(false))

RuleDSL.calcback!(gs, Set(hash.([v8])), Set([v2; v3]));

dv8_dv2 = RuleDSL.getyds(gs, hash(v2), hash(v8))
dv8_dv3 = RuleDSL.getyds(gs, hash(v3), hash(v8))

println(&quot;fib_v8 =&quot;, RuleDSL.getys(gs, hash(v8))[1])
println(&quot;dv8_dv0 =&quot;, dv8_dv2[1])
println(&quot;dv8_dv1 =&quot;, dv8_dv3[1])</code></pre><pre><code class="language-none">fib_v8 =[-0.2716780179347317, -45.04888865659727, -11.925411795165287, -39.021081089012526, -48.0944729708843, -32.662867966376695, 33.76508325264897, 2.191742578524601, 22.88003866501493, -2.188692442315215]
dv8_dv0 =[5.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 5.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 5.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 5.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 5.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 5.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 5.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 5.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 5.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 5.0]
dv8_dv1 =[8.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 8.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 8.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 8.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 8.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 8.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 8.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 8.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 8.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 8.0]
</code></pre><p>A warning is generated if the <span>$\vec x$</span> specification does not capture the sensitivities to all the factors that affects <span>$\vec y$</span>. In the following example, knowing term fib(2) is not adequate to uniquely determine fib(8), therefore a warning is produced.</p><pre><code class="language-julia">RuleDSL.calcback!(gs, Set(hash.([v8])), Set([v2]))</code></pre><pre><code class="language-none">0</code></pre><h2 id="Packaging-1"><a class="docs-heading-anchor" href="#Packaging-1">Packaging</a><a class="docs-heading-anchor-permalink" href="#Packaging-1" title="Permalink"></a></h2><p>When the computation graph becomes large, it can be difficult for a user to navigate and visualize. Julius supports packaged atoms, which is to use a set of Rules to define an atom with its internal computational graph. The packaged atom can then be subsequently referred to by other rules. The iterative layering of rules and packaged atoms allows easy composition of complicated logic and analytics.</p><p>The following code cell shows how to create and use a pacakged atom, using the macro <code>RuleDSL.@combonquantom</code>. A similar <code>RuleDSL.@combodatom</code> is also provided to create packaged <code>Dataom</code> object.</p><pre><code class="language-julia">using GraphEngine.RuleDSL: Source

# the first argument must be the config
@comboquantom function Fib[config::RuleDSL.Config, m::Int](fac.xarg(0), fac.xarg(1))
    fib(n::Int) = Alias(fib(n, Val(n &lt;= 1)))
    fib(n::Int, isend::Val{false}) = begin
        RuleDSL.WeightedSum[[1.0; 1.0]](fib(n - 1, Val(n &lt;= 2)), fib(n - 2, Val(n &lt;= 3)))
    end
    fib(n::Int, isend::Val{true}) = Alias(fac.xarg(n))

    return fib(m)
end

@addrules pack begin
    randv(id::Int, d::Int) = RuleDSL.Constant[[randn(d)]]()
    fib(n::Int, d::Int) = Fib[@config, n](randv(0, d), randv(1, d))
end</code></pre><pre><code class="language-julia">d = 10
p20 = @ref pack.fib(20, d)
p0 = @ref pack.randv(0, d)
p1 = @ref pack.randv(1, d)

gs = RuleDSL.createlocalgraph(config, RuleDSL.NumericalData())
RuleDSL.calcfwd!(gs, Set([p20]));
RuleDSL.calcback!(gs, Set(hash.(p20)), Set([p0; p1]));

dp20dp0 = RuleDSL.getyds(gs, hash(p0), hash(p20))
dp10dp1 = RuleDSL.getyds(gs, hash(p1), hash(p20))

println(&quot;fib20 =&quot;, RuleDSL.getys(gs, hash(p20)))
println(&quot;dfib20_dfib0 =&quot;, dp20dp0[1])
println(&quot;dfib20_dfib1 =&quot;, dp20dp0[1])</code></pre><pre><code class="language-none">fib20 =[[6105.784515200829, -12451.437400523875, 6785.885220022449, 16889.628577006937, -8442.692611540399, -2068.9430046014413, -7835.99923595585, -2509.632991250609, 2121.811351675762, 6472.164427784572]]
dfib20_dfib0 =[4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0]
dfib20_dfib1 =[4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4181.0]
</code></pre><p>The AAD works automatically across the packaged atoms, as shown in the cell above. The follow cell shows that the top level graph is much simpler using the packaged atom. A user can drill down to the full detail of the inner graph of packaged atom from the interactive web UI by clicking on the URL below.</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;pack&quot;);
GraphIO.postsvg(svg, &quot;adv_4.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/depgraph.html?dataurl=127.0.0.1:7140_pack
</code></pre><p align = "center">
<img src="../assets/adv_4.svg" alt="" title="Packaged Atom"/>
</p>
<p align = "center">
Figure 4 - Packaged Atom
</p><h2 id="Error-Handling-1"><a class="docs-heading-anchor" href="#Error-Handling-1">Error Handling</a><a class="docs-heading-anchor-permalink" href="#Error-Handling-1" title="Permalink"></a></h2><p>The Julius Graph Engine handles errors graciously and gives users clear indications on where the errors arise. The follow code create an exception using the <code>Error</code> Quantom at the back AD stage.</p><pre><code class="language-julia">using Test

@clone series =&gt; err

@addrules err begin
    # parameter 2 in Error create error at ad stage
    fib(n::Int, isend::Val{false}) = RuleDSL.Error[2](series.fib(n, isend))
end

efibn = @ref err.fib(10)
xs = Set([@ref series.fib(0); @ref series.fib(1)])

gs = RuleDSL.createlocalgraph(config, RuleDSL.NumericalData())
try
    RuleDSL.calcfwd!(gs, Set([efibn]))
    RuleDSL.calcback!(gs, Set(hash(efibn)), xs)
catch e
    println(&quot;error caught: $e&quot;)
end</code></pre><pre><code class="language-none">0</code></pre><p>The node with error are highlighed automatically in the interactive web UI under the section &quot;errors in graph&quot;.</p><pre><code class="language-julia">svg = GraphIO.postlocalgraph(gss, deepcopy(gs), port, true; key=&quot;err&quot;);
GraphIO.postsvg(svg, &quot;adv_5.svg&quot;)</code></pre><pre><code class="language-none">view graph data at http://127.0.0.1:8080/depgraph.html?dataurl=127.0.0.1:7140_err
</code></pre><p align = "center">
<img src="../assets/adv_5.svg" alt="" title="Error Handling"/>
</p>
<p align = "center">
Figure 5 - Error Handling
</p><h2 id="Manage-Rules-Upgrades-1"><a class="docs-heading-anchor" href="#Manage-Rules-Upgrades-1">Manage Rules Upgrades</a><a class="docs-heading-anchor-permalink" href="#Manage-Rules-Upgrades-1" title="Permalink"></a></h2><p>During the development process, we may need to upgrade certain rules to a newer versions, while encouraging existing users to migrate. This can be achieved through the use of warning messages. For example, if we want to retire the series.fib and migrate users to the new version of vecs.fib, a warning message can be generated for existing users on the old rules:</p><pre><code class="language-julia">@addrules series begin
    fib(n::Int, isend::Val{true}; warn=&quot;deprecated, please use vecs.fib instead&quot;) = begin
        RuleDSL.Constant[[fill(Float64(n), 1)]]()
    end
end

efibn = @ref series.fib(10)
gs = RuleDSL.createlocalgraph(config, RuleDSL.NumericalData(Set{UInt}()))
@time RuleDSL.calcfwd!(gs, Set([efibn]));</code></pre><pre><code class="language-none">┌ Warning: rule series.fib warning: deprecated, please use vecs.fib instead
└ @ Main.##262 /home/julius/dev/Julius/GraphEngine/src/RuleDSL/rulepiler.jl:186
┌ Warning: rule series.fib warning: deprecated, please use vecs.fib instead
└ @ Main.##262 /home/julius/dev/Julius/GraphEngine/src/RuleDSL/rulepiler.jl:186
  0.126431 seconds (292.76 k allocations: 16.505 MiB, 99.11% compilation time)
</code></pre><p>After the migration period has ended, we can change the old rules to throw an error and force users to upgrade.</p><pre><code class="language-julia">@addrules series begin
    fib(n::Int, isend::Val{true}; error=&quot;deprecated, please use vecs.fib instead&quot;) = begin
        RuleDSL.Constant[[fill(Float64(n), 1)]]()
    end
end

gs = RuleDSL.createlocalgraph(config, RuleDSL.NumericalData())
try
    RuleDSL.calcfwd!(gs, Set([efibn]))
catch e
    println(&quot;error caught $e&quot;)
end</code></pre><pre><code class="language-none">error caught rule series.fib: deprecated, please use vecs.fib instead
</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="t005_aad.html">« 5 Adjoint Algorithmic Differentiation (AAD)</a><a class="docs-footer-nextpage" href="t007_persist.html">7 MLOps: ML Experiment Tracking and Persisting »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 29 March 2022 15:50">Tuesday 29 March 2022</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
